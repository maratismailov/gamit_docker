      Subroutine get_map_list( syear,sdoy,sdur,site,slat,slon,lstn )
                                             
c     Read values for mapping function coefficients from a station (list) file 
c     generated by Joannes Boehm of IGG/Vienna.

c     Written by R. King 10 August 2006 from P. Tregoning routine gt/utils/imterp_vmf. 
c     Last modified for new formats by R. King 4 April 2007 

c     See rd_map_list.f for a description of the file and values.
     
      implicit none     
             
      include '../includes/dimpar.h'
      include '../includes/grdtab.h'
      include '../includes/model.h'


c  Input calling arguments     
c   syear           i*4  year of requested day
c   sdoy            i*4  day-of-year of requested start  
c   sdur            r*4  duration of sessions (days)
c   site            c*4  4-character site id to be searched
c   slat            r*4  latitude of site  (decimal deg)
c   slon            r*4  longitude of site (decimal deg)
      integer*4 syear,sdoy
      character*4 site
      real*4 sdur,slat,slon
      logical lstn 

c Input from grdtab.h
c   luprnt               i*4  unit number of print file ('grdtab.out')
c   lumaplg              i*4  unit number for station list file ('map.list')   
c   maxlsit              i*4  maximum number of sites allowed on station list file
c   maplver              r*4  version number for mapping function file                  
c   nsitatml             i*4  number of sites on station list file 
c   sites_map(maxlsit)   c*4  4-character codes for sites in file
c   crds_map(3,maxlsit)  r*4  lat,lon,ht (deg, m ) of sites in file
c   mapmod               c*8  mapping function model
c   nmapl                i*4  number of coefficients for each site and time   

c Output to model.h common /ufcom/  (maxmap in dimpar.h)
c   ntmapl               i*4  number of epochs for each site 
c   map_time(maxmap)     r*4 times in decimal day-of-year of output values 
c   map_val(maxmap,9 )   r*4 mapping function and met values for site 
c   nmap                 i*4 number of MF/met values for each time (4,8,9 for VMF v0.5, 1.0,1.1)
c   ntmap number of values in map_time amd map_val arrays (usually 4/day x 3 days = 12)


c  Search radius within which an alternate site value can be used 
c      (no idea how large this could be and still be reasonable - set it to 10 km)
c PT060825: since we also interpolate over a 250 km grid, why not increase
c           this radius this 50 km
      real*4 search_rad,dlon,dlat,dL,closest
      parameter (search_rad = 50.0) 
      character*4 site1
      logical altsite 

c Other local variables

      logical eoh,found_site,altsit,pasttime
      character*128 line,message
      integer*4 near_site_num,nvals,month,day,mjd,ioerr,yr,doy,sec,i
      real*8  fmjdstart,fmjdstop,time,jd      
c RWK 130116: Rename Aw,Ah to avoid conflict with real*8 variables in
c             model.h (these variables not rally common in grdtab)
      real*4 Awx,Ahx,Zh,Zw,T,press,pw,Tm,deg2rad,h

c*** Put this in common or return?

c  External function    
      character*4 upperc
      integer*4 julday

c  declare value for degree/radians and also initialize the number of VMF values found
      deg2rad = 3.14159265d0/180.d0
      nvals = 0

c  Rewind the file and skip to the beginning of the MF values

      rewind(lumapl)  
      eoh = .false.
      do while (.not.eoh )
        read(lumapl,'(a)',iostat=ioerr) line 
        if(ioerr.ne.0) call report_stat('FATAL','GRDTAB','get_map_list'
     .       ,'map.list','Error searching for *START DATA',ioerr)   
        if( line(1:11).eq.'*START DATA') then
          eoh = .true.
        else
          continue
        endif
      enddo   
               

c  Check for availability of the requested site or an alternative
                                                           
      found_site = .false.
      altsite = .false.  
      do i=1,nsitmap  
        if( site.eq.sites_map(i) ) then
          found_site = .true.
          site1 = site 
        endif
      enddo               

      if( .not.found_site ) then
        closest = search_rad  
        near_site_num = 0  
        do i=1,nsitmap
          dlat = 110.*(crds_map(2,i)-slat)
          dlon = 110.*(crds_map(1,i)-slon)*cos(slat*deg2rad)
          dL   = sqrt(dlat**2 + dlon**2)
          if(dL.lt.closest) then
            closest = dL
            near_site_num = i   
          endif  
        enddo
      endif
      if( near_site_num.gt.0 ) then
        site1 = sites_map(near_site_num)
        altsite = .true.
      endif    
      
c  Compute the number of values to read. Add one for the 2400 UT knot
      ntmap = int( sdur/mapl_int + 0.5) + 1


c  Convert the requested start time to MJD to match file

      call monday(sdoy,month,day,syear)
c        print*,'sdoy,month,day,syear',sdoy,month,day,syear
      mjd = julday(month,day,syear) -2400001
c     subtract a little bit to make the time test easier
      fmjdstart = dfloat(mjd) - .1 
                   

c  Set the stop time              
c     add back the -0.1 and then another 0.1 to make the time test easier
      fmjdstop = fmjdstart + sdur + 0.2 

      
c  Initialize the station-found flag

      lstn = .false.

          
c  Read the first time to see if file starts too late
           
      read(lumapl,'(a)',iostat=ioerr,end=200) line
      if( ioerr.ne.0 ) call report_stat('FATAL','GRDTAB'
     .                    ,'get_map_list','map.list' 
     .         ,'Error reading first data value ',ioerr)
      read(line(5:18),*,iostat=ioerr)  time
      if( ioerr.ne.0 ) call report_stat('FATAL','GRDTAB'
     .                   ,'get_map_list','map.list ' 
     .       ,'Error reading time from first data value',ioerr)
      if( time.gt.fmjdstop ) then   
         write(message,'(a,f8.2,a,f8.2)') 
     .     'First time on map.list file ',time,' > requested day '
     .        ,fmjdstop
         call report_stat('WARNING','GRDTAB','get_map_list'
     .                   ,' ',message,0)
         return          
      endif
                      
c  Scan the file looking for the requested site name and times
                                          
      ntmap = 0  
      pasttime = .false.
      do while (.not.lstn .and. .not.pasttime ) 
        read(lumapl,'(a)',iostat=ioerr,end=200) line
        if( ioerr.ne.0 ) call report_stat('FATAL','GRDTAB'
     .     ,'get_map_list','map.list'
     .     ,'Error reading mapping function list file',ioerr)
        if( upperc(line(1:4)).eq.site)  then 
          if( maplver.eq.0.5 ) then
             read(line(5:128),*,iostat=ioerr)  time,Ahx,Awx,Zh,Zw
          elseif( maplver.eq.1.0 ) then 
            read(line(5:128),*,iostat=ioerr) 
     .          time,Ahx,Awx,Zh,Zw,Tm,press,T,pw   
          elseif( maplver.eq.1.1 ) then   
            read(line(5:128),*,iostat=ioerr) 
     .           time,Ahx,Awx,Zh,Zw,Tm,press,T,pw,h 
          else                                       
            write(message,'(a,f4.1)') 'Unknown map list version',maplver
            call report_stat('FATAL','GRDTAB','get_map_list'
     .         ,'map.list',message,0)
          endif
          if( ioerr.ne.0 )  call report_stat('FATAL','GRDTAB'
     .       ,'get_map_list','map.list','Error decoding values line',0)
          if ( time.gt.fmjdstart .and. time.lt.fmjdstop ) then
            ntmap = ntmap + 1
            if( ntmap.gt.maxmap ) then  
              write(message,'(a,i2,a )') 
     .       'Number of time-sequenced MF values > maxmap (',maxmap,')'
              call report_stat('FATAL','GRDTAB','get_map_list'
     .                         ,'map.list',message,0)
            endif
            jd = time + 2400000.5d0
            call jd_to_yds(jd,yr,doy,sec)
            map_time(ntmap) =  float(doy) + sec/86400.d0
c            print *,'time jd yr doy sec map_time '
c     .            ,time,jd,yr,doy,sec,map_time(ntmap)
            do i=1,9 
              map_val(ntmap,i) = 0.
            enddo
            map_val(ntmap,1) = Ahx
            map_val(ntmap,2) = Awx
            map_val(ntmap,3) = Zh * 1000.0
            map_val(ntmap,4) = Zw * 1000.0    
            if( maplver.ge.1.0 ) then
              map_val(ntmap,5) = Tm
              map_val(ntmap,6) = press
              map_val(ntmap,7) = T
              map_val(ntmap,8) = pw
            endif
            if( maplver.ge.1.1) then
              map_val(ntmap,9) = h
            endif
          endif
c         check if beyond the requested span
c          print *,'fmjdstop time ntmap ',fmjdstop,time,ntmap
          if( time.gt.fmjdstop ) then
            pasttime = .true.
            if( ntmap.gt.0 ) then 
              lstn = .true. 
            else
              write(message,'(a,a4,a,f8.2,a)') 'VMF1 values for '
     .           ,site,' at ',time,' not in map.list'
              call report_stat('WARNING','GRDTAB','get_map_list',' '
     .                        ,message,0)
            endif
          endif 
        endif
      enddo 
c     if found, write a message to grdtab.out and exit
      if( lstn ) then   
        if( .not.altsit ) then
           write(luprnt,'(a4,a,i2)') 
     .        site,' matched in map.list, ntmap=',ntmap   
         else
           write(luprnt,'(a4,a,a4,f4.1,a,i2)') 
     .        site,' matched by alternate ',site1,closest
     .        ,' km away in map.list, ntmap=',ntmap
        endif
        return
      endif
            
c     write what was used to grdtab.out

      write(luprnt,'(a,a8)') '  MAP  list ',otllmod              


c PT060825: if the site exists in the header but there are no actual observations
c           lower in the file then it is possible that we will end up here having
c           read beyond the end of the map.list file
200   continue
      write(luprnt,'(a,a)')'No map.list values found for site: ',site
      lstn = .false.
      ntmap = 0

      return
      end




      subroutine wfica(lun,block_name,itype,fa,ia,ca,nf,ni,nc)
c
c     write a file in FICA (Float, Int, Char (ASCII)) format
c     modified from Judah Levine's WTFICA by kf Mar 5, 87
c     modified by k feigl, Jan 17, 1988 to deal with
c     variable logical unit number
C
C     THIS SUBROUTINE WRITES AN FICA RECORD.  ITYPE IS THE
C     TYPE, NF,NI AND NC ARE THE NUMBER OF FLOATING VARIABLES,
C     INTEGER VARIABLES AND CHARACTER VARIABLES, RESPECTIVELY.
C
C     FA, IA AND CA ARE THE ARRAYS OF FLOATING VARIABLES, INTEGER
C     VARIABLES AND CHARACTER VARIABLES, RESPECTIVELY.
C
C     NOTE THAT THIS SUBROUTINE WRITES TO UNIT 34. CALLER MUST OPEN
C     FILE.
C
C     TO MAINTAIN COMPATABILITY WITH OTHER SOFTWARE, THIS PROGRAM
C     WILL WRITE A BLOCK 8 BEFORE A BLOCK 6 ON THE OUTPUT FILE
C     ALTHOUGH GESAR USUALLY STORES THEM IN OPPOSITE ORDER (BLOCK
C     6 FIRST.  THUS THE LOGIC IS:
C       IF SUBROUTINE IS CALLED WITH BLOCK 6 STORE IT IN HERE
C       IF ANOTHER BLOCK 6 IS PENDING, WRITE IT OUT FIRST
C       IF ANY BLOCK IS RECEIVED WRITE IT AND THEN WRITE BLOCK 6 IF
C       THERE IS ONE PENDING.
C       IF BLOCK 13 IS FOUND (END OF TAPE), WRITE BLOCK 6 IF STILL
C       PENDING.
C       ARRAYS IT6,NF6 .... ARE USED TO STORE THE BLOCK 6
C
C       BLOCK 55, WHEN IMPLEMENTED, WILL BE HANDLED THE SAME WAY
C
C       NOTE THAT ARL/UT SOFTWARE DOES NOT DO THIS EXACTLY, AND
C       FLUSHES THE STORED BLOCK 6 ONLY WHEN ANOTHER BLOCK 6 IS
C       RECEIVED.  THIS IS WHAT THEY SAY BUT NOT WHAT THEY DO.

C     block_name is a dummy inherited from the past -kf 880712
C
c      COMMON/FIC/ITYPE,NF,NI,NC,FA(75),IA(300),CA(8,30)
c
      REAL*8 FA(nf)
C     judah uses an integer*2 ?
      INTEGER*4 IA(ni)
      character*8 ca(nc)
      character*4 block_name
      integer*4   lun
      integer ITYPE,NF,NI,NC,itype6,nf6,nc6,ni6
      REAL*8 FA6(30)
C     judah uses an integer*2 ?
      INTEGER*4 IA6(20)
C
C     NOTE THAT BLOCK 6 HAS NO CHARACTER OUTPUT SO WE DON'T HAVE TO
C     SAVE IT
C
      DATA IBUG / 0 /
C
C
      DATA ITYPE6 / 0 /
      DATA NF6    / 0 /
      DATA NI6    / 0 /
      DATA NC6    / 0 /

C
C      IS CURRENT REQUEST A BLOCK 6 ?
C
      IF(ITYPE .NE. 6) GO TO 100
C
C     IF WE ARE HERE, THE CURRENT BLOCK IS A TYPE 6
C      DO WE HAVE A BLOCK 6 STORED ALREADY?
C
      IF(ITYPE6 .EQ. 0) GO TO 200
C
C      IF WE DO THEN WRITE THE OLD ONE OUT NOW
C
      WRITE(lun,1) ITYPE6,NF6,NI6,NC6
      WRITE(lun,2) (FA6(I),I=1,NF6)
      WRITE(lun,3) (IA6(I),I=1,NI6)
C      call update_tally(itype6,3)
C
C     NOW STORE THE CURRENT BLOCK
C
  200 ITYPE6=ITYPE
      NF6=NF
      NI6=NI
      NC6=NC
      DO 201 I=1,NF6
         FA6(I)=FA(I)
  201 CONTINUE
      DO 202 I=1,NI6
         IA6(I)=IA(I)
  202 CONTINUE
      RETURN
C
C     VARIABLE IBUG USED FOR DEBUGGING PURPOSES
C     NOTHING WILL BE OUTPUT UNTIL A BLOCK WITH A TYPE
C     MATCHING IBUG IS FOUND. AFTER THAT ALL BLOCKS ARE OUTPUT
C
  100 IF( (IBUG .NE. 0) .AND. (ITYPE .NE. IBUG) ) RETURN
      IBUG=0
C
C     IF THE CURRENT BLOCK IS A BLOCK 13, THE END OF TAPE IS AT
C     HAND.  IF THERE IS A BLOCK 6 PENDING, WRITE IT OUT NOW.
C
      IF( (ITYPE .EQ. 13) .AND.  (ITYPE6 .NE. 0) ) THEN
         WRITE(lun,1) ITYPE6,NF6,NI6,NC6
         WRITE(lun,2) (FA6(I),I=1,NF6)
         WRITE(lun,3) (IA6(I),I=1,NI6)
C         call update_tally(itype6,3)
         ITYPE6=0
      ENDIF
C
      WRITE(lun,1) ITYPE,NF,NI,NC
    1 FORMAT('BLK  ',4I5)
      IF(NF .GT. 0) WRITE(lun,2)(FA(I),I=1,NF)
    2 FORMAT(4(1PD20.13))
      IF(NI .GT. 0) WRITE(lun,3)(IA(I),I=1,NI)
    3 FORMAT(6I12)
      IF(NC .GT. 0) WRITE(lun,4)(CA(I),I=1,NC)
    4 FORMAT(10a8)
C      call update_tally(itype,3)
C
C     IF WE HAVE JUST WRITTEN ANY BLOCK AND A BLOCK 6 WAS PENDING
C     THEN WRITE IT OUT NOW.
C
      IF(ITYPE6 .NE. 0) THEN
         WRITE(lun,1)ITYPE6,NF6,NI6,NC6
         WRITE(lun,2)(FA6(I),I=1,NF6)
         WRITE(lun,3)(IA6(I),I=1,NI6)
C         call update_tally(itype6,3)
         ITYPE6=0
      ENDIF

      RETURN
      END

#!/bin/csh -f
# 
#doc Creates GMT plots of station or baselines timeseries from GLOBK/GLORG output.
#doc
#
# Shell script for creating GMT plots of station or baseline time series from the 
# values extracted from a GLRED prt file or GLOBK bak file by sh_globk_scatter 
# and multibase. 
#
# This shell script was written originally at MIT in 1993 by Kurt Feigl and 
# M Burc Oral using output from Tom Herring's programs ensum and bcsum. 
# Last modified by S. McClusky 971124

# MOD TAH 980413: Allowed an extra directory to be specified to overlay
#    time series plots.  The second directory is assumed to have files
#    in the same format as the main directory.
# MOD SMC and TAH: datR type files are considered to be RMS files and
#    no mean or slope is removed.
# MOD KLF: 021105 define ranges, make compatible with SI-compiled GMT
# MOD RWK: 060309: Allow input of tick and annotation values; 060603: Fix bug in 060309
#
if ( $#argv == 0  || `echo $1 | cut -c2-` == "help"   ) then
echo " "    
echo " Shell script for creating GMT plots of station or baseline time series "
echo " from the values extracted from a GLRED prt file or GLOBK bak file by "
echo " sh_globk_scatter and multibase. "
echo " "
echo " Basic usage : "     
echo " "
echo "    sh_baseline -f mb*  "
echo " "    
echo "        -f     :  Files from multibase to be plotted; all begin with mb_ "  
echo " "
echo "    or  -F <filename>  where <filename> is a file containing a list of specific mb_ "
echo "                       files (baselines/stations)"
echo "  "     
echo " Type 'sh_baseline -help' to get a full list of options "
echo " "
echo "    NOTE: if other options invoked, -f must be last"
echo " "   
echo " "
echo " Type 'sh_globk_scatter' or see the GLOBK manual for examples of a full sequence "
echo " of runs to go from GLOBK files to station or baseline repeatabilities."
echo " "      
if ( $argv == "-help" )  then 
echo "--------------------------------------------------------------------------------"
echo " "
echo " Extended sh_baseline features for producing publishable plots"
echo " " 
echo "  -u                   :  Scale factor for uncertainties; default = 1."
echo " "
echo " -com          file    : Creates length file from  bcsum output com-file (component) and gets baseline lengths." 
echo "                         If not issued, the value from values-file is passed to the plot." 
echo "  " 
echo " -sol          file    : Creates length file. from prt/glorg file. Try to avoid -sol (takes long time) and use -com. "
echo "                         If not issued, the value from values-file is passed to the plot." 
echo "  " 
echo " -estimate     file    : Forward Solution prt/glorg file to obtain the estimated velocities." 
echo "  		       This provides a comparison between stochastic and deterministic solution." 
echo "   		       Activated when  -com is issued. "
echo "   		       If -unc_scale issued, uncertainties of estimates will be scaled by this factor" 
echo "   		     " 
echo " -u[nc_scale]    #     : scale all uncertainties with this number. Default is 1." 
echo "  " 
echo " -o[order]       #     : polynomial to be fit to the estimates. 0 for mean  1 for velocity. -1  no trend" 
echo "  " 
echo " -vert                 : No velocity estimation for vertical component. Sets -o to 0." 
echo "  " 
echo " -y[scale]   min max   : vertical   scale.  If not issued it will be calculated."
echo "  " 
echo " -x[scale]   min max   : horizontal scale.  If not issued it will be calculated."
echo "  " 
echo " -year                 : turn on year( year.decimalday)"
echo "                         Default is day. " 
echo "  " 
echo " -n[row]               : turns on 3 rows/column option. Default is 4 rows/column. " 
echo "                         It is designed to plot only 3 components of a baseline." 
echo "                   2   : turns on 2 rows/column option." 
echo "  " 
echo " -cols        val      : Choose 1 or 2 colums of plots per page [default = 2] "
echo "  "
echo " -xframe      value    : x frame ticks. Default is  1. " 
echo "  " 
echo " -xanot       value    : x frame label intervals. Default is  2. " 
echo "  "                                                                       
echo " -yframe      value    : y  frame  ticks. Default is  5. " 
echo "  " 
echo " -yanot       value    : y frame label intervals. Default is  10. " 
echo " " 
echo " -header               : Turn OFF page anw owner line. Good for thesis." 
echo "  " 
echo " -ps       extension   : Extend on  psbase. gmt file name (.  is not necessary)" 
echo "  " 
echo " -c[omment]   text     : Comment entry. Anything other than - as first character of a word. "
echo "                         Use _  instead. ( \> for > )" 
echo "  " 
echo " -p[rinter]  printer   : If system PRINTER  is defined something else." 
echo "  " 
echo " -res                  : plot residuals to fit..." 
echo "  " 
echo " -erase                : remove old psbase files [default is to overwrite" 
echo "  " 
echo " New feature"
echo " -dir directory        : Name of directory with times series to overlay"
echo "                         on primary plots"
echo " New feature (990304)"
echo " -edit <n_sigma>       : Remove data points more than <n_sigma> times the RMS"
echo "                         for the  statistics and plot with light-blue and"
echo "                         orange colors (for primary and secondary data)"
echo "                         This feature needs the 990304 version of poly01r"
echo "  "                                
echo " -ebars                : Do not plot error bars"
echo " " 
echo " -hbars                : Remove horizontal caps on error bars" 
echo "  " 
echo " -line [yr doy]        : New feature. Draw a vertical line at the given time.  "
echo "  "
echo " -maxsigma  val        : Maximum sigma (mm) to plot. " 

endif
exit 0
endif

##################### SET UP DEFAULTS ############################################################
set printer   = ""
set unc_scale = none 
set header   = yes
set xtype    = day
set inst     = ""
set lyr      = ""
set ldoy     = ""
set com      = none
set sol      = none
set yscale   = none
set files    = ""
set FILE     = ""
set comment  = " " 
set psfile   = "psbase"
set xmin     =  0
set xmax     =  0
set ymin     =  0
set ymax     =  0
set order    =  0
set vert     =  unknown
set fakeflag =  yes 
set nrow     =  4
set frame    =  "" 
set xanot0     =  ""   
set yanot0    = ""
set xframe0 = "" 
set yframe0 = ""  
set ADD      = ""
set estimate = ""
set cols = 2
set res  = "no"
set vels = none
set erase  = no
set dir2   = ""
set edit   = 0  
set e_bars = yes  
set h_caps = yes 
set text_color = "-G5/5/5"
set maxsigma = 10000000000.0
# MOD KLF 20021106
set r = `echo "0 0 0 0" | awk '{print $1,$2,$3,$4}'`
#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#

echo " "
echo " Running sh_baseline to create GMT plots of time series"
echo " "

# decipher command line
while ($#argv > 0 )
set input = ( $argv )
switch($input[1])
	case -xt:
	case -xtype:
		set xtype = "year"
                breaksw
	case -year:
		set xtype = "year"
                breaksw
	case -x:
	case -xscale:
		set xmin = $input[2] 
		set xmax = $input[3] 
		shift input
                breaksw
	case -y:
	case -yscale:
		set ymin =  $input[2]
		set ymax =  $input[3]
		shift input
                breaksw
        case -com:
                if ( -e $input[2] ) set com       =  $input[2]
                breaksw
        case -sol:
                if ( -e $input[2] ) set sol       =  $input[2]
                breaksw
        case -u:
        case -unc:
        case -unc_scale:
                set unc_scale     =  $input[2]
	echo ">>>>>> scaling uncertainties by : "  $unc_scale 
                breaksw
        case -ps:
                set psfile       =  psbase_$input[2]
                breaksw
        case -a:
        case -add:
                set ADD       =  "_"$input[2]
                breaksw
        case -r:
        case -res:
                set res       =  "yes"
                breaksw
        case -e:
        case -erase:
                set erase     =  "yes"
                breaksw
        case -edit:
                set edit      = $input[2]
                breaksw
        case -line:
                set lyr      = $input[2]
                set ldoy     = $input[3]
                breaksw
        case -p:
        case -printer:
                set printer   =  $input[2]
                breaksw
        case -header:
                set header    =  no
                breaksw
        case -o:
        case -order:
                set order     =  $input[2]
		if ( $order < 0 ) set fakeflag = no 
                breaksw
        case -vert:
                set vert     =  no
                breaksw
        case -estimate:
                set estimate     =  $input[2]
                breaksw
        case -n:
        case -nrow:
                set nrow     =  3
                if  (`echo  $input[2]  | cut -c1 ` != "-" )   set nrow     =  $input[2]
                breaksw
        case -cols:
                set cols     =   $input[2]  
                breaksw
        case -c:
        case -comment:
		set comment   =   ( $comment $input[2] ) 
		shift input; shift input 
		while ( $#input > 0 &&   `echo  $input[1]  | cut -c1 ` != "-" ) 
			set inarg =  $input[1]
			if ( `echo  $inarg | cut -c1 ` != "-" ) then
				set comment    =   ( $comment $inarg ) 
				shift input
			endif
		end
#               set comment     =  ( $input[2] ) 
		breaksw    
       case -xframe:
                set xframe0     =   $input[2] 
		breaksw
       case -xanot:
                set xanot0     =   $input[2]   
		breaksw                                 
       case -yframe:
                set yframe0     =   $input[2] 
		breaksw
       case -yanot:
                set yanot0     =   $input[2]  
		breaksw
       case -dir:
                set dir2     =   $input[2]  
		breaksw
        case -ebars:
                set e_bars     =   no  
		breaksw
        case -hbars:
                set h_caps     =   no  
		breaksw
	case -f:
        case -file:
                set files        =  (  $input[2-] )
#		\rm -rf tmp.files[1-7]
		echo $files >! tmp.files1
# Paul Tregoning & Simon McClusky turned off argv being set to null to allow -f
# command to appear anywhere in command line, 25th April 1995.
#		set argv = null
		breaksw
	case -F:
        case -FILE:
                set FILE       =    $input[2] 
#	        cat  $FILE | awk '{printf"%-50s ", $1 }' >! tmp.files
		\rm -rf tmp.files[1-7]
	        cat  $FILE | awk 'NR >    0 && NR <=  600  {printf"%-50s ", $1 }' >! tmp.files1
	        cat  $FILE | awk 'NR >  600 && NR <= 1200  {printf"%-50s ", $1 }' >! tmp.files2
	        cat  $FILE | awk 'NR > 1200 && NR <= 1800  {printf"%-50s ", $1 }' >! tmp.files3
	        cat  $FILE | awk 'NR > 1800 && NR <= 2400  {printf"%-50s ", $1 }' >! tmp.files4
	        cat  $FILE | awk 'NR > 2400 && NR <= 3000  {printf"%-50s ", $1 }' >! tmp.files5
	        cat  $FILE | awk 'NR > 3000 && NR <= 3600  {printf"%-50s ", $1 }' >! tmp.files6
	        cat  $FILE | awk 'NR > 3600 && NR <= 4200  {printf"%-50s ", $1 }' >! tmp.files7
		breaksw
        case -maxsigma:
                set maxsigma    = $input[2]
                breaksw
endsw
shift argv
end
#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#
echo COMMENT : $comment

#=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+

set psfile = $psfile$ADD

# clean up!
if ( $erase == "yes" ) then
  \rm -rf  $psfile$ADD.*
endif 

echo "creating "$psfile".*"
echo " "

# scaling/title  information   REconfigure defaults 

# MODIFICATION FOR SI UNITS FOR SHORT COURSE IN FRANCE, PUTAIN
#echo "BASEMAP_FRAME_RGB	= 5/5/5" >! .gmtdefaults 
#gmtdefaults -D | egrep -v 'BASEMAP_FRAME_RGB'  >> .gmtdefaults
#if ( $cols == 1 ) then 
#   echo "LABEL_FONT_SIZE = 12"     >> .gmtdefaults
#   echo "ANOT_FONT_SIZE  = 12"     >> .gmtdefaults
#else
#   echo "LABEL_FONT_SIZE = 10"     >> .gmtdefaults
#   echo "ANOT_FONT_SIZE  = 10"     >> .gmtdefaults
#endif 
#echo "ANOT_OFFSET     = 0.050"  >> .gmtdefaults
#echo "TICK_LENGTH     = -0.075" >> .gmtdefaults

gmtdefaults -D >! .gmtdefaults
gmtset MEASURE_UNIT       inch \
       BASEMAP_FRAME_RGB  5/5/5 \
       ANOT_OFFSET        0.050 \
       TICK_LENGTH        -0.075 

if ( $cols == 1 ) then 
   gmtset LABEL_FONT_SIZE  12
   gmtset ANOT_FONT_SIZE   12
else
   gmtset LABEL_FONT_SIZE  12
   gmtset ANOT_FONT_SIZE   12
endif 



#save the order and res put in
set save_order = $order
set save_res   = $res     

# Setup line to be plotted   
if ( -e tmp.line ) \rm tmp.line
touch tmp.line
if ( $lyr != "" && $ldoy != "" ) then
  if ( $xtype == "year" ) then
    set ldyr = `doy $lyr $ldoy | tail -n -1 | awk '{print $3}'`
    echo $ldyr 0.0 1000.0 >! tmp.line
  else if ( $xtype != "year" ) then
    set ldyr = `doy $lyr $ldoy | tail -n -3 | head -n 1 | awk '{print $6}'`
    echo $ldyr 0.0 1000.0 >! tmp.line
  endif
endif

set NPERPAGE = 8
if ( $cols == 1 ) set NPERPAGE = 4
set N = 0
set PAGE = 1
set FRAME = 0

set yskip = 7.5
if (   $nrow == 3  ) then 
  set NPERPAGE = 6
  set yskip = 6.9
  if ( $cols == 1 ) set NPERPAGE = 3
endif

if (   $nrow == 2  ) then 
  set NPERPAGE = 4
  set yskip = 5.2
  if ( $cols == 1 ) set NPERPAGE = 2
endif

#echo $files 
if ($FILE == "" ) then 
  echo $#files  $NPERPAGE | awk '{ printf "=+=+=+=+=   %4d frames   %4.0f pages =+=+=+=+=\n",$1,$1/$2}'
  echo " "
endif 

if ( -e tmp.length ) \rm -rf tmp.length
if ( $com != none && -e  $com ) then
  cat $com  | grep " 1 L " | awk '{print $1,$5}' | sort -un +1 >! tmp.length
endif

if ( $sol != none && -e  $sol ) then
  cat $sol  | grep " to " | awk '$2 == "to" && NF == 6 {print $1"-"$3,$4/1000}' >! tmp.length
endif

echo " baseline statistics " >! base_stats_$psfile

# make a dummy file
echo "0. 0." >! tmp.0

foreach file_num ( 1 2 3 4 5 6 7  ) 

  set listfile = tmp.files$file_num
  if ( ! -e   $listfile ) goto finishup

  set setoffiles =  (   `cat   $listfile`  ) 
					 # necessary for accounting 
                                       
#cat $listfile
foreach file (   `cat   $listfile`  ) 

#  These are initialized above and read from input.  Why are they
#  reset here??????  TAH 020309?????
#  set frame    =  '' 
#  set anot     =  ''
# MOD TAH 020310: If anot and frame have been set then set the xanot and xframe values
  if( $xanot0 != "" ) set xanot = $xanot0
  if( $xframe0 !="" ) set xframe = $xframe0 

  shift setoffiles
		 # necessary for accounting 

#echo "+=+=+=+=+=+=+=+=    "$file

  @ FRAME = $FRAME + 1 
  @ N = $N + 1

#  set OUT = $psfile.$PAGE

#  get x,y,s from non-header, non-starred data.
#### old multiplot format: year month day hour min 
#   awk '{if ($1 > 80. && $1 < 99 ) print $0}' $file | decyr $xtype >! tmp.dat
### new multibase format  decimal day/year 
  if ( $xmax != 0 && $xmin != 0 ) then
    grep -v '^..[A-Z,a-z]' $file | awk '{ if ($1 >= xmin && $1 <= xmax &&  NR > 1 && NF == 3 && $3 <= ms/1000.0 ) print $0}' xmin=$xmin xmax=$xmax ms=$maxsigma  >! tmp.dat
  else 
    grep -v '^..[A-Z,a-z]' $file | awk '{ if ( NR > 1 && NF == 3 && $3 <= ms/1000.0 )  print $0}' ms=$maxsigma >! tmp.dat
  endif
  
#  get x,y, converting from meters to mm
  awk '{print $1,$2*1000.}' tmp.dat >! tmp.xy
                                       
#  get the number of epochs to allow overriding of slope estimate if only two points
  set nepochs = `cat tmp.xy | wc -l`

#  get s converting from meters to mm
#SCALE the uncertainties
  if ( $unc_scale != none  ) then
    sed s/'$'/"    "$unc_scale/g tmp.dat  >! tmp.dat.scale
    awk '{print $3*1000.*$4}' tmp.dat.scale  >! tmp.sig
  else
#NO scaling 
    awk '{print $3*1000.}' tmp.dat   >! tmp.sig
  endif
  
#  remove 1st order poly from x,y  
  set ftype = `echo $file | awk -F. '{print $NF}'`
  if ( $ftype != datR ) then 
     set mean = `trend1d tmp.xy -Np1 -Fm | head -n 1` 
     awk  '{print $1, $2 - mean}' mean=$mean tmp.xy >! tmp.xr
#    trend1d tmp.xy -Np1 -Fxr  >! tmp.xr  
  else
     set mean = 0.0
     awk  '{print $1, $2 - mean}' mean=$mean tmp.xy >! tmp.xr
#    cat tmp.xy  >!  tmp.xr 
  endif

#  insert sigmas in third column, checking for empty lines
#  pr -m -t -s' ' tmp.xr tmp.sig | awk '{ if (NF == 3) print $0}' >! tmp.xrs
  paste tmp.xr tmp.sig | awk '{ if (NF == 3) print $0}' >! tmp.xrs
  
#######
#   Now repeat the above steps for the second file  
#   Get the file name (with out directory) from $file
  set fname =  `echo $file | awk -F/ '{print $NF}'`

  if( $dir2 != '' && -e $dir2/$fname ) then 
     awk ' NR > 3  {print $0}' $dir2/$fname  >! tmp.dat2
     awk '{print $1,$2*1000.}' tmp.dat2 >! tmp.xy2
     if ( $unc_scale != none  ) then
        sed s/'$'/"    "$unc_scale/g tmp.dat2  >! tmp.dat2.scale
        awk '{print $3*1000.*$4}' tmp.dat2.scale  >! tmp.sig2
     else
#       NO scaling 
        awk '{print $3*1000.}' tmp.dat2   >! tmp.sig2
     endif
     
#    Get the mean from the first site file and remove from the second
#    file (replaced the trend1d call)
     set mean = `trend1d tmp.xy -Np1 -Fm | head -n 1` 
     awk  '{print $1, $2 - mean}' mean=$mean tmp.xy2 >! tmp.xr2
#    insert sigmas in third column, checking for empty lines
#    pr -m -t -s' ' tmp.xr2 tmp.sig2 | awk '{ if (NF == 3) print $0}' >! tmp.xrs2
     paste tmp.xr2 tmp.sig2 | awk '{ if (NF == 3) print $0}' >! tmp.xrs2
     set u2 = 1
  else
  
#    Variable u2 says if we should use the second file. 0 is false.  
     set u2 = 0
   
  endif
########################

#  now find best fitting Nth order polynomial  0 DC   1 vel, -1 no polynomial
#  get header for the baseline
#  if ( -e tmp.length && -e $com   ) then 
  if ( -e tmp.length  ) then 
    set basepar   = ( `cat $file | awk '{if (NR == 2) print $1,$3,$5}' | sed s/"_GPS"/""/g` )
    set length    = `grep $basepar[1] tmp.length | grep  $basepar[2] | awk '{print $2}'`
    if (  $basepar[3] == N ) set  component = +NORTH
    if (  $basepar[3] == E ) set  component = +EAST
    if (  $basepar[3] == U ) set  component = +UP
    if (  $basepar[3] == L ) set  component = LENGTH
    echo $basepar[1] $basepar[2] $component $length | awk '{printf"0.0 1.2 12 0 0 9  %6s to %6s   %9s  %9.3f km\n",$1,$2,$3,$4}' >! tmp.txt 
	 set vels = ""
	 if ( $estimate != "" ) then 
#  Baseline                  Length                  North                 East             Rne     Height
#                       Est.   Adj.  +-        Est.   Adj.  +-          Est.   Adj.  +-             Est.   Adj.  +-
#ANKA_GPS-MELE_GPS    -5.32   -5.32  14.46    -6.55   -6.55   1.20     1.04    1.04   1.62 0.118    51.30   51.30 605.79
#         1              2      3     4          5       6     7        8        9     10    11      12      13     14                   
	   set vel_estimated = ( `grep $basepar[1]  $estimate | grep $basepar[2] | awk ' NF == 14 {print$5,$7,$8,$10,$12,$14,$2,$4}'` )
#        echo .... $basepar[1]  $basepar[2] $vel_estimated
	   if ( $#vel_estimated == 8 ) then
	     if (  $basepar[3] == N ) set vels = ( `echo $vel_estimated | awk '{print $1,$2}' `)
	     if (  $basepar[3] == E ) set vels = ( `echo $vel_estimated | awk '{print $3,$4}' `)
	     if (  $basepar[3] == U ) set vels = ( `echo $vel_estimated | awk '{print $5,$6}' `)
	     if (  $basepar[3] == L ) set vels = ( `echo $vel_estimated | awk '{print $7,$8}' `)
	   endif
    endif

    if ( $basepar[3] == U && $vert == no ) then 
      set order = 0 
    else
      set order = $save_order
    endif

    if ( $ftype == "datR" ) then
      set order = 0 
    else
      set order = $save_order
    endif 
   
  else
    awk '{if (NR == 2) print "0.0 1.2 12 0 0 9 ",$0}' $file | sed s/"_GPS"/""/g |  sed s/"Solution N"/"  +NORTH  "/ | sed s/"Solution E"/"  +EAST   "/ | sed s/"Solution U"/"   +UP    "/ | sed s/"Solution L"/"  LENGTH  "/ \
    | sed s/"to N Solution  1 +"/" North Offset"/ | sed s/"to E Solution  1 +"/" East Offset"/ | sed s/"to U Solution  1 +"/" Up Offset"/  >! tmp.txt
  endif
  
  if ( $FRAME == 1 ) then
    set baseline = `awk ' $8 == "to" {print $7$9} $8 != "to" {print $7}' tmp.txt` 
    set OUT = $psfile.$baseline 
    echo "Plotting: "$baseline
    if ( -e $psfile.$baseline ) \rm -rf $psfile.$baseline
  endif
  if ( $FRAME ==  $nrow  + 1  ) then
    set baseline = `awk ' $8 == "to" {print $7$9} $8 != "to" {print $7}' tmp.txt` 
    \mv $OUT $OUT"_"$baseline  
    set OUT = $OUT"_"$baseline  
    echo "Plotting: "$baseline
  endif
   
  \rm -rf tmp.xm tmp.rate tmprate.txt  tmpxm

# See what we should estimate and display.  Then check exceptions
set order = $save_order 
set res   = $save_res  
if ( ($ftype == "dat3" || $ftype == "datU" ) && ($vert == no) ) then 
  set res   = no 
  set order = 0 
endif

if ( $ftype == "datR") then 
  set order = 0
  set res = no 
endif
       
# MOD RWK 100102: Override slope if only 2 epochs
if( ($nepochs <= 2) ) then
  set res = no
  set order = 0 
endif                         

# MOD TAH: Separate the edited from non-edited data
poly01r yes $order $fakeflag $res $edit <   tmp.xrs >!  tmp.r1

grep -v ' E$' tmp.r1 >! tmp.rate
grep    ' E$' tmp.r1 | awk '{print $1,$3,$4}' >! tmp.redt
 
if( $u2 ) then
#
    poly01r yes $order $fakeflag $res $edit <   tmp.xrs2 >!  tmp.r2
    grep -v ' E$' tmp.r2 >! tmp.rate2
 grep    ' E$' tmp.r2 | awk '{print $1,$3,$4}' >! tmp.redt2  
endif

#if ( $order >= 0    )     more +2   tmp.rate >! tmp.xm
# tmp.xm is the line(0th or 1st order polynomial
  if ( $order >= 0    )   then
    if ( $res == "yes" ) then
      cat   tmp.rate | awk 'NR > 1 {print $1, $2 }'  > tmp.xm 
      cat   tmp.rate | awk 'NR > 1 {print $1, $3 }'  >! tmp.xxm
      if( $u2 ) then
          cat   tmp.rate2 | awk 'NR > 1 {print $1, $2 }'  >! tmp.xm2
      endif 
      if( $u2 ) then
          cat   tmp.rate2 | awk 'NR > 1 {print $1, $3 }'  >! tmp.xxm2
      endif 
    else
      cat   tmp.rate | awk 'NR > 1 {print $0 }'  >! tmp.xm
      if( $u2 ) then
#        cat   tmp.rate2 | awk 'NR > 1 {print $0 }'  >! tmp.xm2
# MOD TAH 990506: Make same as first data set
         cat   tmp.rate | awk 'NR > 1 {print $0 }'  >! tmp.xm2
      endif
    endif
  endif

#poly01r heaader line 
#  wMEAN:     -21.611    41.459 constant:    4804.998   266.836    slope:        -52.3140463685        2.8920943838     obs:      5   nrms:         5.00   wrms:  23.5  
#    1          2         3         4          5          6           7                8                   9             10       11    12           13     14     15
if( $cols == 1 ) then 
  if ( $order == 0  )   then  
# PT040209: we need to use the value of "$mean" rather than what is in tmp.rate (that will always be zero here!)
#    head -n 1   tmp.rate |   awk '{printf"0.0 1.12 12 0 0 9  wmean(mm)= %7.2f @\!+_ %5.2f  nrms= %5.2f  wrms= %5.1f mm # %d\n",$2,$3,$13,$15,$11}' >! tmprate.txt
    head -n 1   tmp.rate |   awk '{printf"0.0 1.12 12 0 0 9  wmean(mm)= %7.2f @\!+_ %5.2f  nrms= %5.2f  wrms= %5.1f mm # %d\n",'$mean',$3,$13,$15,$11}' >! tmprate.txt
    if(  $#vels == 2 && $estimate != "" && $unc_scale == none )  echo $vels           |   awk '{printf" .2 0.97 12 0 0 9 Velocity(mm/yr)= %7.1f @\!+_ %6.1f\n",$1,$2   }' >! tmprate.txt.est
    if(  $#vels == 2 && $estimate != "" && $unc_scale != none )  echo $vels $unc_scale|   awk '{printf" .2 0.97 12 0 0 9 Velocity(mm/yr)= %7.1f @\!+_ %6.1f\n",$1,$2*$3}' >! tmprate.txt.est
  else if ( $order == 1  )   then 
    if ( $xtype == year  ) then
      head -n 1   tmp.rate              |   awk '{printf"0.0 1.12 12 0 0 9 rate(mm/yr)= %7.2f @\!+_ %5.2f  nrms= %5.2f  wrms= %5.1f mm # %d\n",$8,$9,$13,$15,$11}' >! tmprate.txt
      if(  $#vels == 2  && $unc_scale == none )  echo $vels            |   awk '{printf" .2 0.97 12 0 0 9 Velocity(mm/yr)= %7.1f @\!+_ %6.1f\n",$1,$2   }' >! tmprate.txt.est
      if(  $#vels == 2  && $unc_scale != none )  echo $vels $unc_scale |   awk '{printf" .2 0.97 12 0 0 9 Velocity(mm/yr)= %7.1f @\!+_ %6.1f\n",$1,$2*$3}' >! tmprate.txt.est
    else if ( $xtype == day ) then
      head -n 1   tmp.rate              |   awk '{printf"0.0 1.12 12 0 0 9 rate(mm/yr)= %7.2f @\!+_ %5.2f  nrms= %5.2f  wrms= %5.1f mm # %d\n",$8*365.25,$9*365.25,$13,$15,$11}' >! tmprate.txt
    endif
  endif
else 
  if ( $order == 0  )   then  
# PT040209: we need to use the value of "$mean" rather than what is in tmp.rate (that will always be zero here!)
#    head -n 1   tmp.rate |   awk '{printf"0.0 1.12 10 0 0 9  wmean(mm)= %7.2f @\!+_ %5.2f  nrms= %5.2f  wrms= %5.1f mm # %d\n",$2,$3,$13,$15,$11}' >!tmprate.txt 
# RWK040727: with 2 columns the info line is too long, so omit the number of observations
#    head -n 1   tmp.rate |   awk '{printf"0.0 1.12 10 0 0 9  wmean(mm)= %7.2f @\!+_ %5.2f  nrms= %5.2f  wrms= %5.1f mm # %d\n",'$mean',$3,$13,$15,$11}' >! tmprate.txt
    head -n 1   tmp.rate |   awk '{printf"0.0 1.12 10 0 0 9  wmean(mm)= %7.2f @\!+_ %5.2f  nrms= %5.2f  wrms= %5.1f mm \n",'$mean',$3,$13,$15}' >! tmprate.txt
    if(  $#vels == 2 && $estimate != "" && $unc_scale == none )  echo $vels           |   awk '{printf" .2 0.97 10 0 0 9 Velocity(mm/yr)= %7.1f @\!+_ %6.1f\n",$1,$2   }' >! tmprate.txt.est
    if(  $#vels == 2 && $estimate != "" && $unc_scale != none )  echo $vels $unc_scale|   awk '{printf" .2 0.97 10 0 0 9 Velocity(mm/yr)= %7.1f @\!+_ %6.1f\n",$1,$2*$3}' >! tmprate.txt.est
  else if ( $order == 1  )   then 
    if ( $xtype == year  ) then 
# RWK040727: with 2 columns the info line is too long, so omit the number of observations
#      head -n 1   tmp.rate              |   awk '{printf"0.0 1.12 10 0 0 9 rate(mm/yr)= %7.2f @\!+_ %5.2f  nrms= %5.2f  wrms= %5.1f mm # %d\n",$8,$9,$13,$15,$11}' >! tmprate.txt  
      head -n 1   tmp.rate              |   awk '{printf"0.0 1.12 9 0 0 9 rate(mm/yr)= %7.2f @\!+_ %5.2f  nrms= %5.2f  wrms= %5.1f mm \n",$8,$9,$13,$15}' >! tmprate.txt  

      if(  $#vels == 2  && $unc_scale == none )  echo $vels            |   awk '{printf" .2 0.97 10 0 0 9 Velocity(mm/yr)= %7.1f @\!+_ %6.1f\n",$1,$2   }' >! tmprate.txt.est
      if(  $#vels == 2  && $unc_scale != none )  echo $vels $unc_scale |   awk '{printf" .2 0.97 10 0 0 9 Velocity(mm/yr)= %7.1f @\!+_ %6.1f\n",$1,$2*$3}' >! tmprate.txt.est
    else if ( $xtype == day ) then
      head -n 1   tmp.rate              |   awk '{printf"0.0 1.12 10 0 0 9 rate(mm/yr)= %7.2f @\!+_ %5.2f  nrms= %5.2f  wrms= %5.1f mm # %d\n",$8*365.25,$9*365.25,$13,$15,$11}' >! tmprate.txt
    endif
  endif
endif 

######  get ranges #########
# MOD TAH 990304: Cleaned up Range selection 
  if ( $res == "yes" ) then
    set RANGE = `tail -n +3 tmp.rate | awk '{if (NF == 4) {print $1, $3, $4}}'  | minmax  -I.02/10`  
    tail -n +3 tmp.rate | awk '{if (NF == 4) print $1, $3, $4}' >! tmp.xrs  
    if( $u2 ) then
        tail -n +3 tmp.rate2 | awk '{if (NF ==4 ) {print $1, $3, $4}}' >! tmp.xrs2
    endif
  else
     set RANGE = `tail -n +3 tmp.rate  | awk '{if( NF == 4 ) {print $1,$3}}' | minmax  -I.02/10`  
     tail -n +3 tmp.rate |  awk '{if( NF == 4 ) {print $1, $3, $4}}' >! tmp.xrs
     if( $u2 ) then
       tail -n +3 tmp.rate2 | awk '{if( NF ==4 ) {print $1, $3, $4}}' >! tmp.xrs2
     endif
  endif
     
#  echo "RANGE" $RANGE
# set some space for error  bars
#  set r = ( `echo $RANGE | cut -c3- | awk '{FS="/"} {print $1  - ($2-$1)*.10 ,$2 + ($2-$1)*.10,  $3 - ($4-$3)*.10,  $4 + ($4-$3)*.10 }' ` )
  set r = ( `echo $RANGE | cut -c3- | awk -F/ '{print $1  - ($2-$1)*.10 ,$2 + ($2-$1)*.10,  $3 - ($4-$3)*.10,  $4 + ($4-$3)*.10 }' ` )
  if ( $unc_scale != none ||  $order == 1  )   then 
#    set r = ( `echo $RANGE | cut -c3- | awk '{FS="/"} {print $1  - ($2-$1)*.25 ,$2 + ($2-$1)*.25 ,  $3 - ($4-$3)*.5,  $4 + ($4-$3)*.5 }' ` )
    #set r = ( `echo $RANGE | cut -c3- | awk -F/ '{print $1  - ($2-$1)*.10 ,$2 + ($2-$1)*.10 ,  $3 - ($4-$3)*.10,  $4 + ($4-$3)*.10 }' ` )
    set r = ( `echo $RANGE | cut -c3- | awk -F/ '{print $1  - ($2-$1)*.10 ,$2 + ($2-$1)*.10 ,  $3 - ($4-$3)*.10,  $4 + ($4-$3)*.10 }' ` )
  endif     
# debug for bad range:
#  echo $r
# MOD TAH 990530: Check for excessive range (which will cause too many tick marks on axes)
  set dyb = `echo $ymax $ymin | awk '{if ( $2 - $1  > 100 )  {print "BAD"}}'`
  if( $dyb == "BAD" ) then
      echo "Y-Range too large: ymax "$ymax" ymin "$ymin". Resetting"  
      set ymax = 50
      set ymin = -50
  endif
# MOD KLF Check for null range
  set badr = `echo $r | awk '{if ( NF != 4)  {print "BAD"}}'`
  if( $badr == "BAD" || $#r == 0 ) then
     set r = `echo "0 0 0 0" | awk '{print $1,$2,$3,$4}'`
  endif
  if ( $xmin != 0 ) set r[1] = $xmin 
  if ( $xmax != 0 ) set r[2] = $xmax
  if ( $ymin != 0 ) set r[3] = $ymin 
  if ( $ymax != 0 ) set r[4] = $ymax   

# Makesure we have file for the second directory entry
  if( $u2 )  then 
     echo "Adding data from $dir2/$fname"
  else
    if ( -e tmp.xrs2 ) \rm tmp.xrs2
  endif
  
     
#make sure that horizontal min-max has an aperture
  if( $r[1] == $r[2]  ) then
    set r[1] = `echo $r[1] | awk '{print $1 - 1 }'`
    set r[2] = `echo $r[2] | awk '{print $1 + 1 }'`
  endif

#make sure that vertical min-max has an aperture
  if( $r[3] == $r[4]  ) then
#    set r[3] = `echo $r[3] | awk '{print $1 - 10 }'`
#    set r[4] = `echo $r[4] | awk '{print $1 + 10 }'`
    set r[3] =  -10 
    set r[4] =   10 
  endif     

  
# debug for bad range
  set RANGE = "-R"$r[1]"/"$r[2]"/"$r[3]"/"$r[4]
#  echo  "RANGE1 "$RANGE

#
# compute y-axis scales  
  if( $yanot0 == '' ) then
     set yanot  = 10   
  else
     set yanot = $yanot0
  endif
  if( $yframe0 == '' ) then
     set yframe = 5
  else
     set yframe = $yframe0
  endif
  set yl = `echo  $r[4]  $r[3] | awk '{ printf "%6d", ( ( $1 - $2 ) / 100 ) + 1   }'`
  set yanot   = ` echo $yanot   $yl |  awk '{ print  $1 * $2 }' `
  set yframe  = ` echo $yframe  $yl |  awk '{ print  $1 * $2 }' `  

#              
# compute x-axis scales unless given!!!
  set dxr = `echo  $r[2]  $r[1] | awk '{ printf( "%6d", int($1-$2)) }'`

# MOD TAH 020310: changed code completely to make more rational
  set decade = `echo $r[2]  $r[1] | awk '{if($1-$2 >= 1 ) {printf "%6f", 10^(int(log(($1-$2))/2.302585093))} else {printf "%6f", 10^(int(log(($1-$2))/2.302585093))/10}}'` 
# ndxr should be value between 1-9
  set ndxr = `echo  $r[2]  $r[1] $decade | awk '{printf("%6d", ($1-$2)/$3) }'` 
  if( $ndxr < 1 ) then
      set nanot = 0.1
  else if( $ndxr < 2 ) then
      set nanot = 0.2
  else if ( $ndxr < 5 ) then
      set nanot = 1.0
  else if ( $ndxr <= 10 ) then
      set nanot = 2.0 
  endif
       

# Now compute the spacing we need
  if( $cols == 2 ) then
     if( $xanot0 == '' ) set xanot = `echo $nanot $decade | awk '{printf("%7f",$1*$2/2)}'`
     if( $xframe0 == '' ) set xframe = `echo $nanot $decade | awk '{printf("%7f",$1*$2/4)}'`
  else
     if( $xanot0 == '' ) set xanot = `echo $nanot $decade | awk '{printf("%7f",$1*$2/1)}'`
     if( $xframe0 == '' ) set xframe = `echo $nanot $decade | awk '{printf("%7f",$1*$2/2)}'`
  endif
   

# Uncomment below to see what the system is doing
#  echo $ndxr $decade $xanot $xframe $r
# echo "Frames: " $ndxr $decade $nanot $xanot $xframe

### if ( $cols == 2 ) then
# MOD TAH 980731: See if lless than 1
###   if ( $dxr <= 2 && ( $anot == '' || $frame == '' ) ) then
###     set xanot  = 0.05 
###     set xframe = 0.025
###     set xl = `echo  $r[2]  $r[1] | awk '{ printf "%6d", ( ( $1 - $2 )/10 + 1 )  }'`
###     if ( $anot == '' )  set anot   = ` echo $xanot   $xl |  awk '{ print  $1 * $2 }' `
###     if ( $frame == '' ) set frame  = ` echo $xframe  $xl |  awk '{ print  $1 * $2 }' ` 
#      echo $frame $anot
###   endif   
###   if ( $dxr >= 11 && ( $anot == '' || $frame == '' ) ) then       
###     set xanot  = 2 
###     set xframe = 1
###     set xl = `echo  $r[2]  $r[1] | awk '{ printf "%6d", ( ( $1 - $2 )/10 + 1 )  }'`
###     if ( $anot == '' )  set anot   = ` echo $xanot   $xl |  awk '{ print  $1 * $2 }' `
###     if ( $frame == '' ) set frame  = ` echo $xframe  $xl |  awk '{ print  $1 * $2 }' ` 
#      echo $frame $anot
###   endif   
### else
# MOD TAH 980731: See if lless than 2
###   if ( $dxr <= 20 && ( $anot == '' || $frame == '' ) ) then 
###     set xanot  = .05 
###     set xframe = .025
###     echo $frame and $anot
###     set xl = `echo  $r[2]  $r[1] | awk '{ printf "%6f", ( ( $1 - $2 )/4  )   }'`
###     if ( $anot == '' )  set anot   = ` echo $xanot   $xl |  awk '{ print   $2 }' `
###     if ( $frame == '' ) set frame  = ` echo $xframe  $xl |  awk '{ print   $2/2 }' ` 
###     echo $frame $anot $xl
###   endif   
###   if ( $dxr > 20 && ( $anot == '' || $frame == '' ) ) then 
###     set xanot  = 2 
###     set xframe = 1
###     set xl = `echo  $r[2]  $r[1] | awk '{ printf "%6f", ( ( $1 - $2 )/4  )    }'`
###     if ( $anot == '' )  set anot   = ` echo $xanot   $xl |  awk '{ print  $1 * $2 }' `
###     if ( $frame == '' ) set frame  = ` echo $xframe  $xl |  awk '{ print  $1 * $2 }' ` 
#      echo $dxr $frame $anot
###   endif     
### endif
 
# Else frame and anot = 1.
#  if ( $anot == '' )  set anot = 1
#  if ( $frame == '' ) set frame = 1  

# label Y axis with annotation  and frame 
  if (  $FRAME <=  (  $NPERPAGE / 2  )  ||  $cols == 1  ) then
    set SCALES =   "-Ba"$xanot"f"$xframe"/a"$yanot"f"$yframe":(mm):WeSn"
  else 
    set SCALES =   "-Ba"$xanot"f"$xframe"/a"$yanot"f"$yframe":(mm):wESn"
  endif 
#  plot with error bars and very small circles



# Set up the color scheme
# PT990728: allow user to turn off horizontal error bars (default is on)
  if($h_caps == 'no')then
    set Ey1 = '-Ey0.0'
    set Ey2 = '-Ey0.0'
  else
    set Ey1 = '-Ey0.05'
    set Ey2 = '-Ey0.02'
  endif           
# RWK060228: allow user to turn off error bars entirely
  if($e_bars == 'no') then
    set cline  = '-Ss0.001 -W3/0/0/0 -G0/0/0'
    set color  = '-Sc0.040 -W3/0/0/255 -G0/0/255'
    set cedit  = '-Ss0.040 -W3/127/200/255 -G127/200/255'
    set color2 = '-St0.050 -W2/255/0/0 -G255/0/0'
    set cedit2 = '-Si0.050 -W2/255/200/0 -G255/200/0'
  else
   set color  = '-Sc0.040 '$Ey1'/3/0/0/255 -W3/0/0/255 -G0/0/255'
   set cedit  = '-Ss0.040 '$Ey1'/2/127/200/255 -W3/127/200/255 -G127/200/255'
   set cline  = '-Ss0.001 '$Ey1'/2/0/0/0 -W3/0/0/0 -G0/0/0'  
   set color2 = '-St0.050 '$Ey2'/2/255/0/0 -W2/255/0/0 -G255/0/0'
   set cedit2 = '-Si0.050 '$Ey2'/2/255/200/0 -W2/255/200/0 -G255/200/0'
  endif

  if ( $cols != 1 ) then
    if ( $FRAME ==  $nrow  + 1  ) then
      if ( $NPERPAGE >= 8 ) then
        if( -e tmp.xrs2 ) then
           psxy  tmp.xrs2  $RANGE  -JX2.8/1.8 $color2   -P -O -K -Y$yskip  -X+3.5 >> $OUT
           psxy  tmp.xrs  $RANGE  -JX2.8/1.8 $color $SCALES -P -O -K >> $OUT
           psxy  tmp.redt2  -R  -JX $cedit2 $SCALES -P -O -K >> $OUT
           psxy  tmp.redt   -R  -JX $cedit  $SCALES -P -O -K >> $OUT
           psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
        else
           psxy  tmp.xrs  $RANGE  -JX2.8/1.8 $color $SCALES -P -O -K -Y$yskip  -X+3.5>> $OUT
           psxy  tmp.redt  $RANGE  -JX $cedit $SCALES -P -O -K >> $OUT
           psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
        endif
      else if ( $NPERPAGE == 6 ) then
        if( -e tmp.xrs2 ) then
            psxy  tmp.xrs2  $RANGE  -JX2.8/2.6 $color2   -P -O -K -Y$yskip  -X+3.5 >> $OUT
            psxy  tmp.xrs  $RANGE  -JX2.8/2.6 $color $SCALES -P -O -K >> $OUT
            psxy  tmp.redt2  -R  -JX $cedit2 $SCALES -P -O -K >> $OUT
            psxy  tmp.redt   -R  -JX $cedit  $SCALES -P -O -K >> $OUT
            psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
        else
            psxy  tmp.xrs  $RANGE  -JX2.8/2.6 $color $SCALES -P -O -K -Y$yskip  -X+3.5 >> $OUT
            psxy  tmp.redt  $RANGE  -JX $cedit $SCALES -P -O -K >> $OUT
            psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
        endif
      else if ( $NPERPAGE == 4 ) then
        if( -e tmp.xrs2 ) then
            psxy  tmp.xrs2  $RANGE  -JX2.8/4.0 $color2   -P -O -K -Y$yskip  -X+3.5 >> $OUT
            psxy  tmp.xrs  $RANGE  -JX2.8/4.0 $color $SCALES -P -O -K >> $OUT
            psxy  tmp.redt2  -R  -JX $cedit2 $SCALES -P -O -K >> $OUT
            psxy  tmp.redt   -R  -JX $cedit  $SCALES -P -O -K >> $OUT
            psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
        else
            psxy  tmp.xrs  $RANGE  -JX2.8/4.0 $color $SCALES -P -O -K -Y$yskip  -X+3.5 >> $OUT
            psxy  tmp.redt  $RANGE  -JX $cedit $SCALES -P -O -K >> $OUT
            psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
        endif
      endif
    else
      if ( $NPERPAGE >= 8 ) then
        if ( -e $OUT ) then
          if( -e tmp.xrs2 ) then
             psxy  tmp.xrs2  $RANGE  -JX2.8/1.8 $color2   -P -O -K -Y-2.5 >> $OUT
             psxy  tmp.xrs  $RANGE  -JX2.8/1.8 $color $SCALES -P -O -K  >> $OUT
             psxy  tmp.redt2  -R  -JX $cedit2 $SCALES -P -O -K >> $OUT
             psxy  tmp.redt   -R  -JX $cedit  $SCALES -P -O -K >> $OUT
             psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
          else
             psxy  tmp.xrs  $RANGE  -JX2.8/1.8 $color $SCALES -P -O -K -Y-2.5 >> $OUT
             psxy  tmp.redt  $RANGE  -JX $cedit $SCALES -P -O -K >> $OUT
             psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
          endif
      else
          if( -e tmp.xrs2 ) then
             psxy  tmp.xrs2  $RANGE  -JX2.8/1.8 $color2   -P    -K -Y8.5 >! $OUT
             psxy  tmp.xrs  $RANGE  -JX2.8/1.8 $color $SCALES -P  -O  -K  >> $OUT
             psxy  tmp.redt2  -R  -JX $cedit2 $SCALES -P -O -K >> $OUT
             psxy  tmp.redt   -R  -JX $cedit  $SCALES -P -O -K >> $OUT
             psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
          else
             psxy  tmp.xrs  $RANGE  -JX2.8/1.8 $color $SCALES -P  -K -Y8.5 >! $OUT
             psxy  tmp.redt  $RANGE  -JX $cedit $SCALES -P -O -K >> $OUT
             psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
          endif 
        endif
      else if ( $NPERPAGE == 6 ) then
        if ( -e $OUT ) then
          if( -e tmp.xrs2 ) then
             psxy  tmp.xrs2  $RANGE  -JX2.8/2.6 $color2  -P -O -K -Y-3.45 >> $OUT
             psxy  tmp.xrs  $RANGE  -JX2.8/2.6 $color $SCALES -P -O -K  >> $OUT
             psxy  tmp.redt2  -R  -JX $cedit2 $SCALES -P -O -K >> $OUT
             psxy  tmp.redt   -R  -JX $cedit  $SCALES -P -O -K >> $OUT
             psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
          else
             psxy  tmp.xrs  $RANGE  -JX2.8/2.6 $color $SCALES -P -O -K -Y-3.45 >> $OUT
             psxy  tmp.redt  $RANGE  -JX $cedit $SCALES -P -O -K >> $OUT
             psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
          endif  
        else
          if( -e tmp.xrs2 ) then
             psxy  tmp.xrs2  $RANGE  -JX2.8/2.6 $color2   -P  -K -Y7.55  >! $OUT
             psxy  tmp.xrs  $RANGE  -JX2.8/2.6 $color $SCALES -P -O  -K >> $OUT
             psxy  tmp.redt2  -R  -JX $cedit2 $SCALES -P -O -K >> $OUT
             psxy  tmp.redt   -R  -JX $cedit  $SCALES -P -O -K >> $OUT
             psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
          else
             psxy  tmp.xrs  $RANGE  -JX2.8/2.6 $color $SCALES -P -K -Y7.55 >! $OUT
             psxy  tmp.redt  $RANGE  -JX $cedit $SCALES -P -O -K >> $OUT
             psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
          endif
        endif
      else if ( $NPERPAGE == 4 ) then
        if ( -e $OUT ) then
          if( -e tmp.xrs2 ) then
             psxy  tmp.xrs2  $RANGE  -JX2.8/4.0 $color2   -P -O -K -Y-5.2 >> $OUT
             psxy  tmp.xrs  $RANGE  -JX2.8/4.0 $color $SCALES -P -O -K  >> $OUT
             psxy  tmp.redt2  -R  -JX $cedit2 $SCALES -P -O -K >> $OUT
             psxy  tmp.redt   -R  -JX $cedit  $SCALES -P -O -K >> $OUT
             psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
          else
             psxy  tmp.xrs  $RANGE  -JX2.8/4.0 $color $SCALES -P -O -K -Y-5.2 >> $OUT
             psxy  tmp.redt  $RANGE  -JX $cedit $SCALES -P -O -K >> $OUT
             psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
          endif
        else
          if( -e tmp.xrs2 ) then
             psxy  tmp.xrs2  $RANGE  -JX2.8/4.0 $color2  -P -K -Y5.8  >! $OUT
             psxy  tmp.xrs  $RANGE  -JX2.8/4.0 $color $SCALES -P -O   -K  >> $OUT
             psxy  tmp.redt2  -R  -JX $cedit2 $SCALES -P -O -K >> $OUT
             psxy  tmp.redt   -R  -JX $cedit  $SCALES -P -O -K >> $OUT
             psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
          else
             psxy  tmp.xrs  $RANGE  -JX2.8/4.0 $color $SCALES -P -K -Y5.8 >! $OUT
             psxy  tmp.redt  $RANGE  -JX $cedit $SCALES -P -O -K >> $OUT
             psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
          endif          
        endif
      endif
    endif
  else
    if ( $NPERPAGE >= 4 ) then 
      if ( -e $OUT ) then
        if( -e tmp.xrs2 ) then
           psxy  tmp.xrs2  $RANGE  -JX6.5/1.8 $color2  -P -O -K -Y-2.5 >> $OUT
           psxy  tmp.xrs  $RANGE  -JX6.5/1.8 $color $SCALES -P -O -K  >> $OUT
           psxy  tmp.redt2  -R  -JX $cedit2 $SCALES -P -O -K >> $OUT
           psxy  tmp.redt   -R  -JX $cedit  $SCALES -P -O -K >> $OUT
           psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
        else
           psxy  tmp.xrs  $RANGE  -JX6.5/1.8 $color $SCALES -P -O -K -Y-2.5 >> $OUT
           psxy  tmp.redt  $RANGE  -JX $cedit $SCALES -P -O -K >> $OUT
           psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
        endif
      else
        if( -e tmp.xrs2 ) then
           psxy  tmp.xrs2 $RANGE  -JX6.5/1.8 $color2   -P -K -Y8.5  >! $OUT
           psxy  tmp.xrs  $RANGE  -JX6.5/1.8 $color $SCALES -P  -O   -K >> $OUT
           psxy  tmp.redt2  -R  -JX $cedit2 $SCALES -P -O -K >> $OUT
           psxy  tmp.redt   -R  -JX $cedit  $SCALES -P -O -K >> $OUT
           psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
        else
           psxy  tmp.xrs  $RANGE  -JX6.5/1.8 $color $SCALES -P -K -Y8.5 >! $OUT
           psxy  tmp.redt  $RANGE  -JX $cedit $SCALES -P -O -K >> $OUT
           psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
        endif 
     endif
    else if ( $NPERPAGE == 3 ) then
      if ( -e $OUT ) then
        if( -e tmp.xrs2 ) then
           psxy  tmp.xrs2  $RANGE  -JX6.5/2.6 $color2 -P -O -K -Y-3.45  >> $OUT
           psxy  tmp.xrs  $RANGE  -JX6.5/2.6 $color $SCALES  -P -O -K   >> $OUT
           psxy  tmp.redt2  -R  -JX $cedit2 $SCALES -P -O -K >> $OUT
           psxy  tmp.redt   -R  -JX $cedit  $SCALES -P -O -K >> $OUT
           psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
        else
           psxy  tmp.xrs  $RANGE  -JX6.5/2.6 $color $SCALES  -P -O -K -Y-3.45 >> $OUT
           psxy  tmp.redt  $RANGE  -JX $cedit $SCALES -P -O -K >> $OUT
           psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
        endif 
      else
        if( -e tmp.xrs2 ) then
           psxy  tmp.xrs2  $RANGE  -JX6.5/2.6 $color2 -P  -Y7.55  -K >! $OUT
           psxy  tmp.xrs  $RANGE  -JX6.5/2.6 $color $SCALES -P   -O  -K  >> $OUT
           psxy  tmp.redt2  -R  -JX $cedit2 $SCALES -P -O -K >> $OUT
           psxy  tmp.redt   -R  -JX $cedit  $SCALES -P -O -K >> $OUT
           psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
        else
           psxy  tmp.xrs  $RANGE  -JX6.5/2.6 $color $SCALES -P   -K  -Y7.55  >! $OUT
           psxy  tmp.redt  $RANGE  -JX $cedit $SCALES -P -O -K >> $OUT
           psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
        endif 
      endif
    else if ( $NPERPAGE == 2 ) then
      if ( -e $OUT ) then
        if( -e tmp.xrs2 ) then
           psxy  tmp.xrs2  $RANGE  -JX6.5/4.0 $color  -P -O -K -Y-5.2 >> $OUT
           psxy  tmp.xrs  $RANGE  -JX6.5/4.0 $color $SCALES -P -O -K  >> $OUT
           psxy  tmp.redt2  -R  -JX $cedit2 $SCALES -P -O -K >> $OUT
           psxy  tmp.redt   -R  -JX $cedit  $SCALES -P -O -K >> $OUT
           psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
        else
           psxy  tmp.xrs  $RANGE  -JX6.5/4.0 $color $SCALES -P -O -K -Y-5.2 >> $OUT
           psxy  tmp.redt  $RANGE  -JX $cedit $SCALES -P -O -K >> $OUT
           psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
        endif
      else
        if( -e tmp.xrs2 ) then
          psxy  tmp.xrs2  $RANGE  -JX6.5/4.0 $color  -P    -K  -Y5.8 >! $OUT
          psxy  tmp.xrs  $RANGE  -JX6.5/4.0 $color $SCALES -P -O   -K >> $OUT
          psxy  tmp.redt2  -R  -JX $cedit2 $SCALES -P -O -K >> $OUT
          psxy  tmp.redt   -R  -JX $cedit  $SCALES -P -O -K >> $OUT
          psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
        else
          psxy  tmp.xrs  $RANGE  -JX6.5/4.0 $color $SCALES -P  -K -Y5.8 >! $OUT
          psxy  tmp.redt  $RANGE  -JX $cedit $SCALES -P -O -K >> $OUT
          psxy  tmp.line   -R  -JX $cline  $SCALES -P -O -K >> $OUT
        endif 
      endif
    endif
  endif

#  and plot straight line
  psxy  tmp.xm -R -JX -P -O -K >> $OUT

  if ( -e tmprate.txt ) cat tmprate.txt >> tmp.txt
#  print header 
  pstext tmp.txt -R0/1/0/1 -JX -K -P -O -N $text_color >> $OUT
#GMT2 pstext tmp.txt -R0/1/0/1 -JX -K -P -O >> $OUT
  if ( $estimate != "" && -e tmprate.txt.est )    pstext tmprate.txt.est  -R0/1/0/1 -JX -K -P -O -N $text_color >> $OUT
#GMT2 if ( $estimate != "" && -e tmprate.txt.est )    pstext tmprate.txt.est  -R0/1/0/1 -JX -K -P -O >> $OUT
   
  cat tmp.txt | cut -c18- | head -n 1  >!  tmp.txt1
  cat tmp.txt | cut -c18- | tail -n -1  >!  tmp.txt2
  pr -m -t -s -l1  tmp.txt1  tmp.txt2 | head -n 1  >>  base_stats_$psfile

########## 
  if ( $header == yes ) then 
    if (    $FRAME <   $nrow + 1   ) then
       echo " 0.2 -0.25  10 0 0 9 "$comment  "       p: "$PAGE >! tmp.label
    else 
       echo "-0.8 -0.25  10 0 0 9 "$comment  "       p: "$PAGE >! tmp.label
    endif
  else 
# practically out of the page
     echo "-10 -20  10 0 0 9 "$comment  "       p: "$PAGE >! tmp.label
  endif

  if (($N % $NPERPAGE == 0) || ( $#setoffiles == 0 ) ) then
    set yshft = +0.3
#    if ( $FRAME < 4 ) set yshft = -4.8
    pstext tmp.label -R  -U  -JX  -P -O -Y$yshft -N $text_color >> $OUT
#GMT2  pstext tmp.label -R  -U  -JX  -P -O -Y$yshft  >> $OUT
    @ PAGE = $PAGE + 1
    set FRAME = 0 
    echo "Created: "$OUT
  endif

end 
finishup:
end

@ PAGE = $PAGE - 1
echo "  "
echo "  "
if ( $PAGE > 1 ) then
echo "Created  postript files    : "$psfile".*" 
else 
echo "  "
echo "Created  postript files    : "$psfile".*" 
endif
echo "  "
echo "Created  baseline statistics : "base_stats_$psfile
echo "  "
echo "To view  postript files    : gs "$psfile".*"
echo "  "
if ( $printer == "" ) then 
	echo "Hardcopy   postript files  :  lpr -s "$psfile".*"
else
	echo "Hardcopy   postript files  :  lpr -s -P$printer   $psfile.*"
endif
echo "  "
echo "  "
endif

# \rm -rf tmp.label tmprate.txt tmp.rat tmp.0 tmp.files tmp.files1 tmp.dat tmp.xrs tmp.xy tmp.sig tmp.xr tmp.xrs tmp.xm tmp.rate tmprate.txt tmpxm tmprate.txt.est tmp.txt tmp.txt1 tmp.txt2 tmp.xmm tmp.xxm

exit 0
#gs $psfile.*


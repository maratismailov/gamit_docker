#!/bin/csh -f
#
#doc Create plots of baseline repeatability versus length from GLRED print files or GLOBK bak file
#doc
# 
# Shell script for creating GMT plots of baseline repeatability versus length
# from GLRED print files or GLOBK bak file.  This script must also be run
# to create the files necessary to plot a time series of station or baseline  
# values using program multibase and the shell script sh_baseline.
#
# This shell script was written originally as 'sh_globk_repeatability_gmt' by M. Burc Oral 
# at MIT in 1993 and later revised by Simon McClusky, 1994-96.
# Last modified by R. King  980325           
#
# Requirements:  GMT(netcdf/gmt/ghostscript); gamit/utils(svdsig, svdlin, poly01) 
#     
if ( $#argv == 0  || `echo $1 | cut -c2-` == "help"   ) then
echo "  "
echo "  Script to calculate and plot baseline scatter (wrms in mm and nrms) vs length from"
echo "  a GLRED print file or GLOBK bak file.  Basic usage: "
echo "  Basic usage : "
echo " "      
echo "           sh_globk_scatter -f <file>   "
echo " "
echo "     -f[ile]      : Input GLRED prt or GLOBK bak file "
echo " "                                                   
echo " "
echo "  There are three types of outputs of potential use in evaluating the quality of a "
echo "  survey or series of surveys:"
echo " "
echo "   ps1.*  ps2.* :  Graphical postscript files displaying wrms and nrms scatters,"
echo "                   respectively, versus baseline length for all baseline combinations"
echo "  "                         
echo "   sum.*     com.*                  :  The nrms and wrms values used to create the plots."
echo "   com.*.sort.wrms  com.*.sort.nrms |  sum is ordered by station, as in the input file;"                   
echo "                                       sum is ordered by baseline length, for plotting;"
echo "                                       the last two are ordered by rms values and are the "
echo "                                       most useful for identifying the baselines which appear"
echo "                                       anomalous in the plots"
echo " "
echo "   val.*  VAL.* : The individual values, for baselines and stations, respectively, used "
echo "                  to calculate the rms.  These files allow you to determine the actual day"
echo "                  or survey causing the a large nrms.  They are also useful to give detail -n (date)"
echo "                  and residual value) for the time series generated by sh_baseline (see below)" 
echo "  " 
echo "   In each of the above * is replaced by the name of the input file."
echo " "                                                   
echo "  Additional options : "
echo " "  
echo "    -[l]ength   maxlen : Maximum baseline to plot (defines horizontal scale); default is 1400 km. "
echo " "
echo "    -n[umber]  n       : n is the min sites required for computation; default is 2. "
echo "  "
echo "    -help              : List extended features for formatting final plots "
echo " "
if ( $argv == "-help" )  then  
echo " "
echo "  Complete sequence for generating plots scatter plots and baseline repeatabilities"
echo "  for a single survey over days to weeks:"
echo " "
echo "   - Create a file (e.g, 'baselines') listing the combinations you want to plot as time series"
echo "     Format:  SITE1                | plot all combinations with SITE1 "
echo "              SITE2 SITE3          | plot SITE2-SITE3"
echo "              SITE3 SITE6          | plot SITE3-SITE6"
echo "                                   | **NOTE first column must be blank "
echo " "
echo "    - Given, e.g., GLRED output file expmt.prt, execute in order "
echo " "
echo "          sh_globk_scatter -f expmt.prt         | creates expmt.ps1  expmt.ps2  " 
echo "                                                |         val.expmt  VAL.expmt "   
echo "                                                |         sum.expmt  com.expmt com.expmt.sort.wrms com.expmt.sort.nrms "
echo " "
echo "          multibase val.* -s baselines -d       | creates mb_ files for all combinations requested"
echo " "   
echo "          sh_baseline -f mb*                    | creates [sitename].ps files "
echo " "
echo "    -  Display or print the plots"
echo "  "
echo "          lpr expmt.ps1 expmt.ps2 *.ps "  
echo " "
echo "    Type 'multibase' and/or 'sh_baseline -help' to view the complete options for these programs"
echo "  "
echo "-------------------------------------------------------------------------------------------------"
echo "  "
echo "  Extended sh_globk_scatter features for producing publishable plots"     
echo "  "
echo " -long              : Turns ON long-term statistics to be plotted. Default is short."
echo "  "
echo " -vert              : Turns OFF -long option for vertical component"
echo "  "
echo " -n[umber]  n       : n is the min sites required for computation; default is 2. "
echo "  "
echo " -[l]ength   maxlen : Maximum baseline to plot (defines horizontal scale); default is 1400 km. "
echo "  "
echo " -wrms     max-wrms : Maximum wrms scatter (defines vertical scale); default is 100 mm."
echo "  "
echo " -nrms     max-nrms : Maximum nrms scatter (defines vertical scale); default is 10."
echo "  "
echo " -svdsig            : Turns OFF svdsig option. For real good solutions you NEED this option"
echo "                    :  sigma**2  = a**2  + b**2  L**2"
echo "  "
echo " -svdlin            : Turns OFF svdlin option. "
echo "                    :  sigma    = a     + b L  "
echo "  "
echo " -i[nfo_type]       : Turns off default short style.  "
echo "  "
echo " -scale       ####  : Scales the nrms with this number. Default is 1. "
echo "  "
echo " -i[nfo_type]       : Turns OFF short format. You get alot of statistics. Whether you need is another question."
echo "  "
echo " -h[elp]            : Print help information"
echo "  "
echo " -p[rinter] xxxx    : Select printer; default is sparc if PRINTER is null. "
echo "  "
echo " -gmt               : Start  gmt, ASSUME xxSUM has been run. Issue a component file with -file .  "
echo "  "
echo " -ppm               : Execute ppm computation. Takes rather long time."
echo "  "
echo " -ppb               : Execute ppb computation. Takes rather long time."
echo "  "
echo " -filter descriptor : filter files with descriptor paths"
echo "                    : Great for COMBINATION solutions"
echo "  "
echo " -filter2  reject_value : see wether we want to do two step bcsum: good for globk COMBINATION  solutions "
echo "                     *REJECT rms > 20    cm(default) : remove baseline info uncertainties above 20 cm"
echo "                     *REJECT rms < .001  cm          : remove baseline info with 0.000 entries "
echo "                     *REJECT repeated lines          : remove repeated baseline info[combined data set]"
echo "                     requires fortran executable bcsum_filter_val.exe"
echo "  "
echo " -k[ill]      site  :  permanently delete additional site from the bak-file. May be issued several times."
echo "                       Even though a site is killed in globk, baseline information exists in the"
echo "                       bak-file. To exclude that/those site/sites use this option or add it/them "
echo "                       in sites_delete or create a another delete file and use -delete_file option "
echo " -sk[ill]     site  :  SOFT kill. Deletes  from temporary files. These sites will be ignored in "
echo "                       statistics and plots. FASTER. Can also be USEd   with -gmt option." 
echo "                       The original com-file is left untouched."
echo "  " 
echo " -uk[ill]     site  :  SOFT kill. Deletes UP     components  from temporary files. These sites will be ignored in "
echo "                       statistics and plots. The original file is untouched."
echo "  " 
echo " -nk[ill]     site  :  SOFT kill. Deletes NORTH  components  from temporary files. These sites will be ignored in "
echo "                       statistics and plots. The original file is untouched."
echo "  " 
echo " -ek[ill]     site  :  SOFT kill. Deletes EAST   components  from temporary files. These sites will be ignored in "
echo "                       statistics and plots. The original file is untouched."
echo "  " 
echo " -lk[ill]     site  :  SOFT kill. Deletes LENGTH components  from temporary files. These sites will be ignored in "
echo "                       statistics and plots. The original file is untouched."
echo "  "
echo " -h[eader]           : TURN OFF header prints. Good for thesis plots. Default is ON, print header."
echo "  "
echo " -delete_file  file : file contains the names of unwanted sites."
echo "  "
echo " -d[elete]   no     : DO NOT DELETE sites, If  ../../tables/sites_delete  and/or  ./sites_delete exists. "
echo "  "
echo " -c[omment]  text   : No need for quotes. This option should be issued LAST " 
echo " -inch              : set inch as unit in gmt.conf " 
echo "  "   
endif
exit
endif
########## defaults ##############
set header       =  yes
set file        = bak-file
set kill        = ""
set skill   = ""
set lkill   = ""
set nkill   = ""
set ekill   = ""
set ukill   = ""
set printer = " "
set help        = no 
set gmt         = no 
set ppm         = no
set ppb         = no
set number      = 2 
set filter      = no 
set filter2      = no 
set delete      = yes 
set comment     = ""
set svdsig      = yes 
set svdlin      = yes 
set delete_file = none
set xlabel =  f100a250  
set maxlength   = 1400
set maxwrms     = 100
set maxnrms     = 10
set multiplier  = .002
set mode        = short 
set vert     =  unknown
set info_type = short
set scale = none 
set inch = no
#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#
# decipher command line 
while ($#argv > 0 ) 
set input = ( $argv ) 
switch($input[1])
	case -f:
	case -file:
		set file        =  $input[2]
		breaksw
	case -scale:
		set scale        =  $input[2]
		breaksw
	case -h:
	case -header:
		set header      =  no
		breaksw
	case -help:
		set help        =  yes
		breaksw
	case -gmt:
		set gmt       =  yes
		breaksw
	case -i:
	case -info_type:
		set info_type  =  allinfo
		breaksw
	case -svdsig:
		set svdsig       =  no
		breaksw
	case -svdlin:
		set svdlin       =  no
		breaksw
	case -filter:
		set filter      =  $input[2]
		breaksw
	case -filter2:
		set filter2      =  $input[2]
		breaksw
	case -n:
	case -number:
		set number      =  $input[2] 
		breaksw
	case -ppm:
		set ppm         =  yes
		breaksw
	case -ppb:
		set ppb         =  yes
		breaksw
	case -long:
		set mode         =  long
		breaksw
        case -vert:
                set vert     =  novelocity
                breaksw
	case -inch:
		set inch     = yes
	breaksw
	case -k:
	case -kill:
		set kill      =  ( $kill $input[2] ) 
		breaksw
	case -sk:
	case -skill:
#		set skill      =  ( $skill $input[2] ) 
		set skill = (`echo $argv | cut -d- -f2`); shift skill
		breaksw
	case -lk:
	case -lkill:
#		set lkill      =  ( $lkill $input[2] ) 
		set lkill = (`echo $argv | cut -d- -f2`); shift lkill
		breaksw
	case -uk:
	case -ukill:
#		set ukill      =  ( $ukill $input[2] ) 
		set ukill = (`echo $argv | cut -d- -f2`); shift ukill
		breaksw
	case -ek:
	case -ekill:
#		set ekill      =  ( $ekill $input[2] ) 
		set ekill = (`echo $argv | cut -d- -f2`); shift ekill
		breaksw
	case -nk:
	case -nkill:
#		set nkill      =  ( $nkill $input[2] ) 
		set nkill = (`echo $argv | cut -d- -f2`); shift nkill
		breaksw
	case -d:
	case -delete:
		set delete      =  no
		breaksw
	case -delete_file:
		set delete_file =  $input[2]
		breaksw
	case -p:
	case -printer:
		set printer     =  -P$input[2]
		breaksw
	case -l:
	case -length:
		set maxlength     =  $input[2]
		if (  $maxlength      < 1501  ) then 
			set xlabel =  f125a250  
		else if (  $maxlength  > 1500 &&  $maxlength  < 2001 ) then 
			set xlabel =  f100a500
		else if (  $maxlength  > 2000  &&  $maxlength  < 6001) then 
			set xlabel =  f250a2000
		else if (  $maxlength  > 6000 ) then 
			set xlabel =  f250a2500
		endif
		echo .............. label $xlabel
		breaksw
	case -wrms:
		set maxwrms     = $input[2]
		breaksw
	case -nrms:
		set maxnrms     = $input[2]
		breaksw
	case -c:
        case -comment:
		shift input
	while (  $#input > 0 ) 
			set comment    =   ( $comment $input[1] ) 
			shift input
	end
		endsw #!end of the command line input
        breaksw
endsw 
shift argv 
end
#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#

#echo  $file $filter $number $ppm $help $printer $comment

\rm -f tmp.val tmp.com.$file tmp[neul].bak.test  tmp.fit.* tmpNRMS* tmp.ns tmp.ew tmp.ud tmp.bl



if ( $help   == yes ) goto optionhelp
if ( $gmt  == yes ) goto optiongmt



if ( -e $file  ) then
  /bin/cp  $file tmp.val 
else 
	echo $file " does not exist ...... exiting ....."
	exit
endif

#DELETE SITES 
	set sites_delete = ( "PRN_" ) 

if ( $delete != no ) then 
	 if   ( -e  ../../tables/sites_delete) then
		set sites_delete = ( $sites_delete `cat  ../../tables/sites_delete ` ) 
	else  if ( ! -e  ../../tables/sites_delete &&  -e ./sites_delete ) then
		set sites_delete = ( $sites_delete `cat sites_delete ` ) 
	endif
endif

if ( $delete_file != none   ) then 
	 if   ( -e  $delete_file ) then
		set sites_delete = ( `cat  $delete_file` ) 
	endif
endif

echo  deleting :  $sites_delete $kill
   foreach i( $sites_delete $kill)
	grep -v -a  $i tmp.val  >!  tmp.val1
	/bin/mv  tmp.val1  tmp.val
   end 


if ( $filter2  == "no"  ) then 

 	if ( $filter   != "no"  ) then 
		echo FILTER   $filter  out from  $file
		label_baksol < tmp.val >! tmp.val2
		cat tmp.val2 | grep -v -a $filter     | cut -c1-131 >! tmp.val
	 endif

	\rm -rf      sum.$file val.$file  com.$file SUM.$file VAL.$file 
   echo " "
   echo " sh_globk_scatter calling bcsum..." 
	bcsum $number sum.$file val.$file  com.$file tmp.val 
   echo " "
   echo " sh_globk_scatter calling ensum..." 
	ensum $number SUM.$file VAL.$file            tmp.val

else if ( $filter2  != "no"  ) then 
	echo " "
   echo " sh_globk_scatter calling bcsum/ensum.. " 
	\rm -rf  sum val  com  SUM    VAL   
	bcsum $number sum.$file val.$file  com.$file tmp.val 
	bcsum $number sum    val     com    tmp.val      
   echo " "
   echo " sh_globk_scatter calling bcsum/ensum with filters.." 
	ensum $number SUM    VAL            tmp.val
	bcsum_filter_val   val  tmp.com $filter
	bcsum_filter_val   VAL  tmp.com $filter
	\rm -rf  sum.$file val.$file  com.$file  SUM.$file VAL.$file   
	bcsum $number sum.$file val.$file  com.$file tmp.com
	ensum $number SUM.$file VAL.$file            tmp.com
endif 

# Sort bcsum com. file
 set colsort1 = 7 
 set colsort2 = 8 
 if ( $mode == long  ) set colsort1 = 11
 if ( $mode == long  ) set colsort2 = 12 
 head -n 5  com.$file >! com.tmp.sort1
 head -n 5  com.$file >! com.tmp.sort2
 head -n 5  com.$file >! com.tmp
 cat  com.$file | grep " N " | sort -u -k $colsort1 >> com.tmp.sort1
 cat  com.$file | grep " N " | sort -u -k $colsort2 >> com.tmp.sort2
 cat  com.$file | grep " N " | sort -u -k 4 >> com.tmp
 head -n 5  com.$file >> com.tmp.sort1
 head -n 5  com.$file >> com.tmp.sort2
 head -n 5  com.$file >> com.tmp
 cat  com.$file | grep " E " | sort -u -k $colsort1 >> com.tmp.sort1
 cat  com.$file | grep " E " | sort -u -k $colsort2 >> com.tmp.sort2
 cat  com.$file | grep " E " | sort -u -k 4 >> com.tmp
 head -n 5  com.$file >> com.tmp.sort1
 head -n 5  com.$file >> com.tmp.sort2
 head -n 5  com.$file >> com.tmp
 cat  com.$file | grep " U " | sort -u -k $colsort1 >> com.tmp.sort1
 cat  com.$file | grep " U " | sort -u -k $colsort2 >> com.tmp.sort2
 cat  com.$file | grep " U " | sort -u -k 4 >> com.tmp
 head -n 5  com.$file >> com.tmp.sort1
 head -n 5  com.$file >> com.tmp.sort2
 head -n 5  com.$file >> com.tmp
 cat  com.$file | grep " L " | sort -u -k $colsort1 >> com.tmp.sort1
 cat  com.$file | grep " L " | sort -u -k $colsort2 >> com.tmp.sort2
 cat  com.$file | grep " L " | sort -u -k 4 >> com.tmp
 /bin/mv  com.tmp.sort1  com.$file".sort.wrms"
 /bin/mv  com.tmp.sort2  com.$file".sort.nrms"
 /bin/mv  com.tmp  com.$file
# Sort ensum SUM. file
 set colsort1 = 6 
 set colsort2 = 7 
 if ( $mode == long  ) set colsort1 = 10
 if ( $mode == long  ) set colsort2 = 11 
 head -n 5  SUM.$file >! SUM.tmp.sort1
 head -n 5  SUM.$file >! SUM.tmp.sort2
 head -n 5  SUM.$file >! SUM.tmp
 cat  SUM.$file | grep " N " | sort -u -k $colsort1 >> SUM.tmp.sort1
 cat  SUM.$file | grep " N " | sort -u -k $colsort2 >> SUM.tmp.sort2
 cat  SUM.$file | grep " N " | sort -u -k 4 >> SUM.tmp
 head -n 5  SUM.$file >> SUM.tmp.sort1
 head -n 5  SUM.$file >> SUM.tmp.sort2
 head -n 5  SUM.$file >> SUM.tmp
 cat  SUM.$file | grep " E " | sort -u -k $colsort1 >> SUM.tmp.sort1
 cat  SUM.$file | grep " E " | sort -u -k $colsort2 >> SUM.tmp.sort2
 cat  SUM.$file | grep " E " | sort -u -k 4 >> SUM.tmp
 head -n 5  SUM.$file >> SUM.tmp.sort1
 head -n 5  SUM.$file >> SUM.tmp.sort2
 head -n 5  SUM.$file >> SUM.tmp
 cat  SUM.$file | grep " U " | sort -u -k $colsort1 >> SUM.tmp.sort1
 cat  SUM.$file | grep " U " | sort -u -k $colsort2 >> SUM.tmp.sort2
 cat  SUM.$file | grep " U " | sort -u -k 4 >> SUM.tmp
 head -n 5  SUM.$file >> SUM.tmp.sort1
 head -n 5  SUM.$file >> SUM.tmp.sort2
 head -n 5  SUM.$file >> SUM.tmp
 cat  SUM.$file | grep " L " | sort -u -k $colsort1 >> SUM.tmp.sort1
 cat  SUM.$file | grep " L " | sort -u -k $colsort2 >> SUM.tmp.sort2
 cat  SUM.$file | grep " L " | sort -u -k 4 >> SUM.tmp
 /bin/mv  SUM.tmp.sort1  SUM.$file".sort.wrms"
 /bin/mv  SUM.tmp.sort2  SUM.$file".sort.nrms"
 /bin/mv  SUM.tmp  SUM.$file

echo "  "
echo created  sum.$file
echo created  SUM.$file
echo created  val.$file
echo created  VAL.$file
echo created  com.$file
echo created  com.$file".sort.wrms"
echo created  com.$file".sort.nrms"
echo created  SUM.$file".sort.wrms"
echo created  SUM.$file".sort.nrms"

optiongmt: 
echo .... running GMT ......
echo .... creating plot input files 

  if ( $gmt == yes ) then
#	cat  $file >!  tmp.com.$file
echo "cat  com.$file | awk '"\$4"> "$number -1 "{print}' " >! tmprep.csh 
#echo "cat  $file | awk '"\$4"> "$number -1 "{print}' " >! tmprep.csh 
csh tmprep.csh  >!  tmp.com.$file
  else
  /bin/cp    com.$file  tmp.com.$file
  endif
 if ( $#skill > 0 ) then 
   echo "Soft kill :" $skill
   foreach i( $skill )
	grep -v  $i tmp.com.$file  >!  tmp.com1.$file
	/bin/mv  tmp.com1.$file  tmp.com.$file
   end 
 endif 


	grep '1 L'  tmp.com.$file >! tmpl.$file
	grep '2 N'  tmp.com.$file >! tmpn.$file
	grep '3 E'  tmp.com.$file >! tmpe.$file
	grep '4 U'  tmp.com.$file >! tmpu.$file

        
 if ( $#lkill > 0 ) then 
   echo "Soft kill LENGTH only :" $lkill
   foreach i( $lkill )
	grep -v  $i tmpl.$file  >!  tmp1.$file
	/bin/mv  tmp1.$file  tmpl.$file
   end 
 endif
                
 if ( $#ekill > 0 ) then 
   echo "Soft kill EAST   only :" $ekill
   foreach i( $ekill )
	grep -v  $i tmpe.$file  >!  tmp1.$file
	/bin/mv  tmp1.$file  tmpe.$file
   end 
 endif

 if ( $#nkill > 0 ) then 
   echo "Soft kill NORTH  only :" $nkill
   foreach i( $nkill )
	grep -v  $i tmpn.$file  >!  tmp1.$file
	/bin/mv  tmp1.$file  tmpn.$file
   end 
 endif

 if ( $#ukill > 0 ) then 
   echo "Soft kill UP     only :" $ukill
   foreach i( $ukill )
	grep -v  $i tmpu.$file  >!  tmp1.$file
	/bin/mv  tmp1.$file  tmpu.$file
   end 
 endif


 cat  tmpl.$file  tmpn.$file  tmpe.$file  tmpu.$file >!  tmp.com.$file


foreach i ( ns ew ud bl ) 
#echo "created plot file :  com_"$i  
echo "  "$file"  "  $comment  >! com_$i
echo "    Baseline      Type  #      Length      Type Mean    +-    wrms  nrms       slope   +-    wrms  nrms   dur mean" >>  com_$i
echo "  " >>  com_$i
echo "  " >>  com_$i
end

		grep  " 2 N "  tmp.com.$file  >>  com_ns
		grep  " 3 E "  tmp.com.$file  >>  com_ew
		grep  " 4 U "  tmp.com.$file  >>  com_ud
		grep  " 1 L "  tmp.com.$file  >>  com_bl


set title = ( $argv) 
#    Baseline      Type  #      Length      Type Mean    +-    wrms  nrms       slope   +-    wrms  nrms   dur mean
#                                (km)         (mm)      (mm)    (mm)         (mm/yr) (mm/yr)   (mm)          (yrs)
#MEKE_GPS-ULDA_GPS  2 N    3     84.378        3549.7    1.4    2.4  2.10       1.0     3.0    3.3  2.81   4.0 1992.5
#         1         2 3    4      5              6        7      8     9        10      11      12   13    14   15


foreach i ( ew ns ud  bl ) 
if ( $mode == short  ) then 
#=#=#=#=#=#=  SHORT  TERM REPEAT
	more +5 com_$i | awk '{printf"%10.3f %6.1f %6.1f \n",$5,$8,$7}'| sort >! tmp.$i
	more +5 com_$i | awk '{printf"%10.3f %6.2f       \n",$5,$9   }'| sort >! tmpNRMS.$i
#=#=#=#=#=#=  LONG TERM REPEAT
else  if ( $mode == long ) then 
	more +5 com_$i | awk '{printf"%10.3f %6.1f %6.1f \n",$5,$12,$11}'| sort >! tmp.$i
	more +5 com_$i | awk '{printf"%10.3f %6.2f       \n",$5,$13   }'| sort >! tmpNRMS.$i
endif 
end

#
foreach i ( ud  ) 
if ( $mode == long && $vert == novelocity  ) then 
echo #=#=#=#=#=#=  SHORT  TERM REPEAT
	more +5 com_$i | awk '{printf"%10.3f %6.1f %6.1f \n",$5,$8,$7}'| sort >! tmp.$i
	more +5 com_$i | awk '{printf"%10.3f %6.2f       \n",$5,$9   }'| sort >! tmpNRMS.$i
endif 
end

if ( $scale != none  ) then 
	foreach i ( ew ns ud bl ) 
		cat  tmpNRMS.$i       |  sed s/'^'/"`echo $scale`"/  >! tmpNRMS.$i.scaled
		cat tmpNRMS.$i.scaled | awk '{printf"%10.3f %6.2f       \n",$2,$3/$1}' >!  tmpNRMS.$i
	end
endif


foreach i ( ew ns ud bl ) 
#***   Estimate the precision of the measurements as a function
#*     of baseline length according to the general model:
#*           sigma^2 = a^2 + b^2*L^2
if ( $svdsig == yes ) 	cat  tmp.$i | awk '{print $1*1000,$2/1000}' | svdsig |  awk '{if (NR == 1) {print $0 } else {print $1,$3}}'  >! tmp.fit.nonln.$i
if ( $svdlin == yes ) 	cat  tmp.$i | awk '{print $1*1000,$2/1000}' | svdlin |  awk '{if (NR == 1) {print $0 } else {print $1,$3}}'  >! tmp.fit.linear.$i
end


# scaling/title  information 
 gmt gmtdefaults -Du >! gmt.conf
# modif phil vernant
if ($i == "yes") gmt gmtset PROJ_LENGTH_UNIT i
# fin de modif
 gmt gmtset FONT_LABEL 12p \
            FONT_ANNOT_PRIMARY 12p
# print svdsig[modified]  -->  a(mm) and b(ppm)   ---->>    a(mm) and b(ppb)
#  5 dof:   172.00 SDUW:  0.06738 Damp:  0.00000 a (m ) :    0.00497   0.00902 b (ppm):    0.01086   0.01158
#  1  2       3       4       5    6         7   8  9   10     11        12    13 14        15        16
# wMEAN:       3.044     8.888 constant:       2.340     0.276    slope:          0.0019842495        0.0007094823      obs:     79     nrms:       2.143     wrms:       2.116
#   1            2          3     4               5        6         7                  8                    9           10      11      12          13        14         15     

                                  echo "0.25  9.5   15p REPEATABILITY 1       WRMS Scatter "            >! tmp.text
if ($info_type !=  short  ) then 
if ( $svdsig == yes ) head -n 1 tmp.fit.nonln.ns | awk '{printf"0.00  5.375  10p NS a(mm)  %9.2f @\+_ %8.2f \n",$11,$12}'               >> tmp.text
if ( $svdsig == yes ) head -n 1 tmp.fit.nonln.ns | awk '{printf"0.00  5.250  10p NS b(ppb)  %9.2f @\+_ %8.2f \n",1000*$15,1000*$16}'    >> tmp.text
if ( $svdlin == yes ) head -n 1 tmp.fit.linear.ns| awk '{printf"0.00  5.125  10p NS        c(mm) %9.2f @\+_ %8.2f \n",$11,$12}'         >> tmp.text
if ( $svdlin == yes ) head -n 1 tmp.fit.linear.ns| awk '{printf"0.00  5.000  10p NS slope(ppb) %9.2f @\+_ %8.2f \n",1000*$15,1000*$16}' >> tmp.text
        cat tmp.ns | poly01 no 1 no |  head -n 1 | awk '{printf"0.00  4.875  10p NS about slope wrms(mm) %6.2f nrms: %6.2f  \n",$15,$13}' >> tmp.text
        cat tmp.ns | poly01 no 0 no |  head -n 1 | awk '{printf"0.00  4.750  10p NS mean(mm)%8.2f @\+_ %8.2f  Baseline:  %5d \n",$2,$3,$11}'   >> tmp.text
        cat tmp.ns | poly01 no 0 no |  head -n 1 | awk '{printf"0.00  4.625  10p NS about mean wrms(mm) %6.2f nrms: %6.2f  \n",$15,$13}' >> tmp.text

if ( $svdsig == yes ) head -n 1 tmp.fit.nonln.ew | awk '{printf"4.00  5.375  10p EW a(mm)  %9.2f @\+_ %8.2f \n",$11,$12}'     >> tmp.text
if ( $svdsig == yes ) head -n 1 tmp.fit.nonln.ew | awk '{printf"4.00  5.250  10p EW b(ppb) %9.2f @\+_ %8.2f \n",1000*$15,1000*$16}'     >> tmp.text
if ( $svdlin == yes ) head -n 1 tmp.fit.linear.ew| awk '{printf"4.00  5.125  10p EW         c(mm)  %9.2f @\+_ %8.2f \n",$11,$12}'       >> tmp.text
if ( $svdlin == yes ) head -n 1 tmp.fit.linear.ew| awk '{printf"4.00  5.000  10p EW  slope(ppb) %9.2f @\+_ %8.2f \n",1000*$15,1000*$16}'>> tmp.text
        cat tmp.ew | poly01 no 1 no |  head -n 1 | awk '{printf"4.00  4.875  10p EW about slope wrms(mm) %6.2f nrms: %6.2f  \n",$15,$13}' >> tmp.text
        cat tmp.ew | poly01 no 0 no |  head -n 1 | awk '{printf"4.00  4.750  10p EW mean(mm)%8.2f @\+_ %8.2f  Baseline:  %5d \n",$2,$3,$11}'   >> tmp.text
        cat tmp.ew | poly01 no 0 no |  head -n 1 | awk '{printf"4.00  4.625  10p EW about mean wrms(mm) %6.2f nrms: %6.2f  \n",$15,$13}' >> tmp.text

if ( $svdsig == yes ) head -n 1 tmp.fit.nonln.ud | awk '{printf"0.00  0.700  10p UD a(mm)  %9.2f @\+_ %8.2f \n",$11,$12}'     >> tmp.text
if ( $svdsig == yes ) head -n 1 tmp.fit.nonln.ud | awk '{printf"0.00  0.575  10p UD b(ppb) %9.2f @\+_ %8.2f \n",1000*$15,1000*$16}'     >> tmp.text
if ( $svdlin == yes ) head -n 1 tmp.fit.linear.ud| awk '{printf"0.00  0.450  10p UD        c(mm)  %9.2f @\+_ %8.2f \n",$11,$12}'        >> tmp.text
if ( $svdlin == yes ) head -n 1 tmp.fit.linear.ud| awk '{printf"0.00  0.325  10p UD  slope(ppb) %9.2f @\+_ %8.2f \n",1000*$15,1000*$16}' >> tmp.text
        cat tmp.ud | poly01 no 1 no |  head -n 1 | awk '{printf"0.00  0.200  10p UD about slope wrms(mm) %6.2f nrms: %6.2f  \n",$15,$13}' >> tmp.text
        cat tmp.ud | poly01 no 0 no |  head -n 1 | awk '{printf"0.00  0.075  10p UD mean(mm)%8.2f @\+_ %8.2f  Baseline:  %5d \n",$2,$3,$11}'   >> tmp.text
        cat tmp.ud | poly01 no 0 no |  head -n 1 | awk '{printf"0.00 -0.050  10p UD about mean wrms(mm) %6.2f nrms: %6.2f  \n",$15,$13}' >> tmp.text

if ( $svdsig == yes ) head -n 1 tmp.fit.nonln.bl | awk '{printf"4.00  0.700   10p BL a(mm)  %9.2f +_ %8.2f \n",$11,$12}'       >> tmp.text
if ( $svdsig == yes ) head -n 1 tmp.fit.nonln.bl | awk '{printf"4.00  0.575   10p BL b(ppb) %9.2f @\+_ %8.2f \n",1000*$15,1000*$16}'     >> tmp.text
if ( $svdlin == yes ) head -n 1 tmp.fit.linear.bl| awk '{printf"4.00  0.450   10p BL        c(mm)   %9.2f @\+_ %8.2f \n",$11,$12}'       >> tmp.text
if ( $svdlin == yes ) head -n 1 tmp.fit.linear.bl| awk '{printf"4.00  0.325   10p BL  slope(ppb) %9.2f @\+_ %8.2f \n",1000*$15,1000*$16}' >> tmp.text
        cat tmp.bl | poly01 no 1 no |  head -n 1 | awk '{printf"4.00  0.200   10p BL about slope wrms(mm) %6.2f nrms: %6.2f  \n",$15,$13}' >> tmp.text
        cat tmp.bl | poly01 no 0 no |  head -n 1 | awk '{printf"4.00  0.075   10p BL mean(mm)%8.2f @\+_ %8.2f  Baseline:  %5d \n",$2,$3,$11}'   >> tmp.text
        cat tmp.bl | poly01 no 0 no |  head -n 1 | awk '{printf"4.00 -0.050   10p BL about mean wrms(mm) %6.2f nrms: %6.2f  \n",$15,$13}' >> tmp.text
else
##### short info
if ( $svdsig == yes ) head -n 1 tmp.fit.nonln.ns  | awk '{printf"0.00  5.35  10p NS @~s@~@+2@+(mm)  = a@+2@+(mm)    +      b@+2@+(ppb) x  L@+2@+(mm)   \n"}'   >> tmp.text
if ( $svdsig == yes ) head -n 1 tmp.fit.nonln.ns  | awk '{printf"0.00  5.20  10p NS a(mm): %9.2f       b(ppb):  %9.2f   \n",$11,1000*$15}'         >> tmp.text
if ( $svdlin == yes ) head -n 1 tmp.fit.linear.ns | awk '{printf"0.00  5.00  10p NS @~s@~(mm)   = c(mm)     +    m(ppb) x  L(mm)   \n"}'        >> tmp.text
if ( $svdlin == yes ) head -n 1 tmp.fit.linear.ns | awk '{printf"0.00  4.85  10p NS c(mm): %9.2f       m(ppb):  %9.2f   \n",$11,1000*$15}'         >> tmp.text
         cat tmp.ns | poly01 no 0 no |  head -n 1 | awk '{printf"0.00  4.65  10p NS mean(mm)= %8.2f   Baseline:  %5d \n",$2,$11}'   >> tmp.text

if ( $svdsig == yes ) head -n 1 tmp.fit.nonln.ew  | awk '{printf"4.00  5.35  10p EW @~s@~@+2@+(mm)  = a@+2@+(mm)    +      b@+2@+(ppb) x  L@+2@+(mm)   \n"}'   >> tmp.text
if ( $svdsig == yes ) head -n 1 tmp.fit.nonln.ew  | awk '{printf"4.00  5.20  10p EW a(mm): %9.2f       b(ppb):  %9.2f   \n",$11,1000*$15}'         >> tmp.text
if ( $svdlin == yes ) head -n 1 tmp.fit.linear.ew | awk '{printf"4.00  5.00  10p EW @~s@~(mm)   = c(mm)     +    m(ppb) x  L(mm)   \n"}'        >> tmp.text
if ( $svdlin == yes ) head -n 1 tmp.fit.linear.ew | awk '{printf"4.00  4.85  10p EW c(mm): %9.2f       m(ppb):  %9.2f   \n",$11,1000*$15}'         >> tmp.text
         cat tmp.ew | poly01 no 0 no |  head -n 1 | awk '{printf"4.00  4.65  10p EW mean(mm)= %8.2f   Baseline:  %5d \n",$2,$11}'   >> tmp.text

if ( $svdsig == yes ) head -n 1 tmp.fit.nonln.ud  | awk '{printf"0.00  0.65  10p UD @~s@~@+2@+(mm)  = a@+2@+(mm)    +      b@+2@+(ppb) x  L@+2@+(mm)   \n"}'   >> tmp.text
if ( $svdsig == yes ) head -n 1 tmp.fit.nonln.ud  | awk '{printf"0.00  0.50  10p UD a(mm): %9.2f       b(ppb):  %9.2f   \n",$11,1000*$15}'         >> tmp.text
if ( $svdlin == yes ) head -n 1 tmp.fit.linear.ud | awk '{printf"0.00  0.30  10p UD @~s@~(mm)   = c(mm)     +    m(ppb) x  L(mm)   \n"}'        >> tmp.text
if ( $svdlin == yes ) head -n 1 tmp.fit.linear.ud | awk '{printf"0.00  0.15  10p UD c(mm): %9.2f       m(ppb):  %9.2f   \n",$11,1000*$15}'         >> tmp.text
         cat tmp.ud | poly01 no 0 no |  head -n 1 | awk '{printf"0.00  0.00  10p UD mean(mm)= %8.2f   Baseline:  %5d \n",$2,$11}'   >> tmp.text

if ( $svdsig == yes ) head -n 1 tmp.fit.nonln.bl  | awk '{printf"4.00  0.65  10p BL @~s@~@+2@+(mm)  = a@+2@+(mm)    +      b@+2@+(ppb) x  L@+2@+(mm)   \n"}'   >> tmp.text
if ( $svdsig == yes ) head -n 1 tmp.fit.nonln.bl  | awk '{printf"4.00  0.50  10p BL a(mm): %9.2f       b(ppb):  %9.2f   \n",$11,1000*$15}'         >> tmp.text
if ( $svdlin == yes ) head -n 1 tmp.fit.linear.bl | awk '{printf"4.00  0.30  10p BL @~s@~(mm)   = c(mm)     +    m(ppb) x  L(mm)   \n"}'        >> tmp.text
if ( $svdlin == yes ) head -n 1 tmp.fit.linear.bl | awk '{printf"4.00  0.15  10p BL c(mm): %9.2f       m(ppb):  %9.2f   \n",$11,1000*$15}'         >> tmp.text
         cat tmp.bl | poly01 no 0 no |  head -n 1 | awk '{printf"4.00  0.00  10p BL mean(mm)= %8.2f   Baseline:  %5d \n",$2,$11}'   >> tmp.text


endif

if ( $header == yes  )  then 
echo "0.00 -0.30  10p " $file "                   " $comment   >> tmp.text
endif
 
if ( -e  ps1.$file ) \rm -f  ps1.$file
#PLOT parameters 
gmt pstext tmp.text  -h0 -R0/8.5/0/11 -Jx1i/1i  -F+f+jTL  -K -P     >! ps1.$file

#****---------- start actual GMT plotting 

# PLOT SCATTER 
set RANGE =  ( `echo $maxlength $maxwrms | awk '{print "-R0/"$1"/0/"$2  "  -Jx"2.8/$1"/"3.0/$2  }' `)
set fa = f1a5
if ( $maxwrms >= 50   ) set fa = f1a5
if ( $maxwrms >= 100  ) set fa = f5a10
if ( $maxwrms >= 200  ) set fa = f10a20
if ( $maxwrms >= 500  ) set fa = f25a100
if ( $maxwrms >= 2000 ) set fa = f50a200
#echo $RANGE

                     gmt psxy  tmp.ns              $RANGE -h0 -P -K -O    -Sx.05i -X0.25i  -Y6.0i   -Bx$xlabel+l'Baseline Length(km)' -By$fa+l'N-S    WRMS (mm)' -BWeSn >> ps1.$file
if( $svdsig == yes ) gmt psxy  tmp.fit.nonln.ns    $RANGE -h1 -P -K -O    -W1p,,20:0                                                                               >> ps1.$file
if( $svdlin == yes ) gmt psxy  tmp.fit.linear.ns   $RANGE -h1 -P -K -O    -W1p                                                                                    >> ps1.$file

                     gmt psxy  tmp.ew              $RANGE -h0 -P -K -O    -Sx.05i -X3.75i             -Bx$xlabel+l'Baseline Length(km)' -By$fa+l'E-W    WRMS (mm)' -BWeSn >> ps1.$file
if( $svdsig == yes ) gmt psxy  tmp.fit.nonln.ew    $RANGE -h1 -P -K -O    -W1p,,20:0                                                                                >> ps1.$file
if( $svdlin == yes ) gmt psxy  tmp.fit.linear.ew   $RANGE -h1 -P -K -O    -W1p                                                                                    >> ps1.$file

                     gmt psxy  tmp.ud              $RANGE -h0 -P -K -O    -Sx.05i -X-3.75i -Y-4.75i  -Bx$xlabel+l'Baseline Length(km)' -By$fa+l'U-D    WRMS (mm)' -BWeSn >> ps1.$file
if( $svdsig == yes ) gmt psxy  tmp.fit.nonln.ud    $RANGE -h1 -P -K -O    -W1p,,20:0                                                                                >> ps1.$file
if( $svdlin == yes ) gmt psxy  tmp.fit.linear.ud   $RANGE -h1 -P -K -O    -W1p                                                                                    >> ps1.$file

                     gmt psxy  tmp.bl              $RANGE -h0 -P -K -O    -Sx.05i -X3.75i          -Bx$xlabel+l'Baseline Length(km)' -By$fa+l'Length WRMS (mm)' -BWeSn  >> ps1.$file
if( $svdsig == yes ) gmt psxy  tmp.fit.nonln.bl    $RANGE -h1 -P -K -O    -W1p,,20:0                                                                                >> ps1.$file
if( $svdlin == yes ) gmt psxy  tmp.fit.linear.bl   $RANGE -h1 -P    -O    -W1p                                                                                    >> ps1.$file

# PLOT NRMS 
foreach i ( ew ns ud bl ) 
gmt trend1d  tmpNRMS.$i   -Np1 -Fxm  -V >&! tmp.trend1d 
set mean = ` grep Model tmp.trend1d | cut -c20- `
	echo "NRMS ...... ">!  tmpNRMS.fit.$i
	foreach j ( 0 100 500 1000 10000) 
		echo $j $mean >> tmpNRMS.fit.$i
	end
set mean_$i = $mean
end 

                       echo "0.25  9.5   15p REPEATABILITY 2       Normalized    RMS "                                       >! tmpNRMS.text
echo $mean_ns | awk '{printf"0.25  4.95  10p NS-Mean Normalized RMS : %8.2f \n",$1 }'                          >> tmpNRMS.text
echo $mean_ew | awk '{printf"4.25  4.95  10p EW-Mean Normalized RMS : %8.2f \n",$1 }'                          >> tmpNRMS.text
echo $mean_ud | awk '{printf"0.25  0.15  10p UD-Mean Normalized RMS : %8.2f \n",$1 }'                          >> tmpNRMS.text
echo $mean_bl | awk '{printf"4.25  0.15  10p BL-Mean Normalized RMS : %8.2f \n",$1 }'                          >> tmpNRMS.text
sh_percent tmpNRMS.ns 70 90  | awk '{printf"0.25  5.15  10p NS %4d%3s %5.2f     %4d%3s %5.2f \n",$1,"% <",$2,$3,"% <",$4}'   >> tmpNRMS.text
sh_percent tmpNRMS.ew 70 90  | awk '{printf"4.25  5.15  10p EW %4d%3s %5.2f     %4d%3s %5.2f \n",$1,"% <",$2,$3,"% <",$4}'   >> tmpNRMS.text
sh_percent tmpNRMS.ud 70 90  | awk '{printf"0.25  0.30  10p UD %4d%3s %5.2f     %4d%3s %5.2f \n",$1,"% <",$2,$3,"% <",$4}'   >> tmpNRMS.text
sh_percent tmpNRMS.bl 70 90  | awk '{printf"4.25  0.30  10p BL %4d%3s %5.2f     %4d%3s %5.2f \n",$1,"% <",$2,$3,"% <",$4}'   >> tmpNRMS.text

if ( -e  ps2.$file ) \rm -f  ps2.$file
#PLOT parameters 
if ( $header == yes  )  then 
echo "0.00 -0.30  10p " $file "                   " $comment   >>  tmpNRMS.text
endif

gmt pstext tmpNRMS.text  -h0 -R0/8.5/0/11 -Jx1i/1i -F+f+jTL  -K -P     >! ps2.$file


set RANGE =  ( `echo $maxlength $maxnrms | awk '{print "-R0/"$1"/0/"$2  "  -Jx"2.8/$1"/"3.0/$2  }' `)
 set fa = f.5a1
if ( $maxnrms >= 5   ) set fa = f.5a1
if ( $maxnrms >= 10  ) set fa = f1a2
if ( $maxnrms >= 20  ) set fa = f2.5a5
if ( $maxnrms >= 50  ) set fa = f5a10
if ( $maxnrms >= 200 ) set fa = f5a20

gmt psxy  tmpNRMS.ns              $RANGE -h0 -P -K -O    -Sx.05i -X0.25i  -Y6.0i   -Bx$xlabel=l'Baseline Length(km)' -By$faR+l'N-S   Normalized RMS' -BWeSn  >> ps2.$file
gmt psxy  tmpNRMS.fit.ns          $RANGE -h1 -P -K -O    -W1p                                                                                         >> ps2.$file
 
gmt psxy  tmpNRMS.ew              $RANGE -h0 -P -K -O    -Sx.05i -X3.75i             -Bx$xlabel+l'Baseline Length(km)' -By$fa+l'E-W   Normalized RMS' -BWeSn  >> ps2.$file
gmt psxy  tmpNRMS.fit.ew          $RANGE -h1 -P -K -O    -W1p                                                                                         >> ps2.$file

gmt psxy  tmpNRMS.ud              $RANGE -h0 -P -K -O    -Sx.05i -X-3.75i -Y-4.75i  -Bx$xlabel+l'Baseline Length(km)' -By$fa+l'U-D   Normalized RMS' -BWeSn  >> ps2.$file
gmt psxy  tmpNRMS.fit.ud          $RANGE -h1 -P -K -O    -W1p                                                                                         >> ps2.$file

gmt psxy  tmpNRMS.bl              $RANGE -h0 -P    -O    -Sx.05i -X3.75i          -Bx$xlabel+l'Baseline Length(km)' -By$fa+l'Length Normalized RMS' -BWeSn  >> ps2.$file
gmt psxy  tmpNRMS.fit.bl          $RANGE -h1 -P -K -O    -W1p                                                                                         >> ps2.$file


##****----------  finish  GMT plotting 

cat tmp.text      | cut -c 24- >! rep.$file
cat  tmpNRMS.text | cut -c 24- >> rep.$file 
echo Created rep.$file


if ( $ppm == yes ) then
###### calculate PPM 
#wrms[mm]/( L[km]*1,000,000)[mm]  * 1,000,000 = [ppm]
cat com.$file  | grep GPS | awk '{printf"%20s     %20.3f%10.5f %20.1f \n", $1, $5,$8/$5,$8}' >! scatter.baseline 

echo "BASELINE                 LENGTH             L-scatter              N-scatter              E-scatter             U-scatter   " >! ppm.scatter
echo "                          [km]           [ppm]     [mm]         [ppm]     [mm]         [ppm]     [mm]         [ppm]     [mm]" >>  ppm.scatter
foreach baseline  ( ` cat scatter.baseline  | awk '{print $1 }' | sort -du  ` ) 
set length = `grep $baseline scatter.baseline  |  awk '{print $2}'`
echo  $baseline  $length[1] `grep $baseline scatter.baseline |  awk '{print $3"  " $4}'` | awk '{printf"%15s%15.3f%15.4f%8.1f%15.4f%8.1f%15.4f%8.1f%15.4f%8.1f\n",$1,$2,$3,$4,$5,$6,$7,$8,$9,$10}' >>  tmp.ppm.scatter
end
#sort wrt L 
sort -k 1,2.200  tmp.ppm.scatter >>  ppm.scatter
echo "                          [km]           [ppm]     [mm]         [ppm]     [mm]         [ppm]     [mm]         [ppm]     [mm]" >>  ppm.scatter
echo "BASELINE                 LENGTH             L-scatter              N-scatter              E-scatter             U-scatter   " >>  ppm.scatter

     
        sed s/'$'/"    "ppm.$file/  ppm.scatter >! ppm.$file
	\rm -f  ppm.scatter  scatter.baseline  tmp.ppm.scatter 
	echo "Created  ppm.$file"
endif 


if ( $ppb == yes ) then
###### calculate PPB 
#wrms[mm]/( L[km]*1,000,000)[mm]  * 1,000,000 * 1000  = [ppb] 
cat com.$file  | grep GPS | awk '{printf"%20s     %20.3f%10.5f %20.1f \n", $1, $5,$8/$5*1000,$8}' >! scatter.baseline 

echo "BASELINE                 LENGTH             L-scatter              N-scatter              E-scatter             U-scatter   " >! ppb.scatter
echo "                          [km]            [ppb]    [mm]          [ppb]    [mm]          [ppb]    [mm]          [ppb]    [mm]" >>  ppb.scatter
foreach baseline  ( ` cat scatter.baseline  | awk '{print $1 }' | sort -du  ` ) 
set length = `grep $baseline scatter.baseline  |  awk '{print $2}'`
echo  $baseline  $length[1] `grep $baseline scatter.baseline |  awk '{print $3"  " $4}'` | awk '{printf"%15s%15.3f%15.1f%8.1f%15.1f%8.1f%15.1f%8.1f%15.1f%8.1f\n",$1,$2,$3,$4,$5,$6,$7,$8,$9,$10}' >>  tmp.ppb.scatter
end
#sort wrt L 
sort -k 1,2.200  tmp.ppb.scatter >>  ppb.scatter
echo "                          [km]            [ppb]    [mm]          [ppb]    [mm]          [ppb]    [mm]          [ppb]    [mm]" >>  ppb.scatter
echo "BASELINE                 LENGTH             L-scatter              N-scatter              E-scatter             U-scatter   " >>  ppb.scatter

     
        sed s/'$'/"    "ppb.$file/  ppb.scatter >! ppb.$file
	\rm -f  ppb.scatter  scatter.baseline  tmp.ppb.scatter 
	echo "Created  ppb.$file"
endif 


\rm -f tmp* com_ud com_ew com_ns com_bl com val sum rmprep.csh  tmp.val tmp.com.$file tmp[neul].bak.test  tmp.fit.* tmpNRMS* tmp.ns tmp.ew tmp.ud tmp.bl  
if ( $inch == "yes" ) \rm -f gmt.conf
optionhelp:
if ( $help == yes) sh_globk_repeatability 
if ( $ppm == yes ) echo " scatter info:    ppm."$file  
# modi phil vernant
if ( $ppb == yes ) echo " scatter info:    ppb."$file  
# fin de modif
echo " "
echo "  To view    : gs  " ps1.$file ps2.$file
echo " "
echo "  To print  :  lpr  "$printer  ps1.$file ps2.$file
echo " "
echo " "
echo "#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#= "
echo "                       TIME SERIES  INFO "
echo "#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#= "
echo " "
echo "   STEP 1.     multibase                 "
echo "   STEP 2.     sh_baseline               "
echo " "
echo "  To get baseline time-series plots  run "
echo " "
echo "          multibase " val.$file  -d 
echo " or       multibase " val.$file  -d  -s base
echo " "
echo "          multibase " val.$file  -y 
echo " or       multibase " val.$file  -y  -s base
echo " "
echo " and TO PLOT  use"
echo " "
echo "          sh_baseline  -f mb*"
echo " "
echo " "
echo "  To get site time-series plots  run "
echo " "
echo "          multibase " VAL.$file  -d 
echo " or       multibase " VAL.$file  -d  -s base
echo " "

echo "          multibase " VAL.$file  -y 
echo " or       multibase " VAL.$file  -y  -s base
echo " "
echo " and TO PLOT  use"
echo " "
echo "          sh_baseline   -n 3 -f mb*"
echo " "
echo "#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#= "
exit 



CTITLE DECODE_OPTION
 
      subroutine decode_option( buffer, cont_types, num_types, conts,
     .                          default_cont )

      implicit none 
 
 
*     Routine to read a buffer line from the markov file and decode
*     the contribution types and set the corresponding bits in the
*     'conts' array.
*     If the 'RESET' command is given then conts is set equal to
*     the default_cont.
*     The type may be proceeded with a minus sign to force a
*     contribution to be turned off. (An optional plus sign can
*     also be used, but no sign defaults to plus).

* MOD TAH 961206: Added feature to ignore anything after ! or # in line
* MOD TAH 030607: Added wild card feature in decode.  Strings of the form
*     XXXX_* or XXXX_@ will set (or reset) all bits assocaited with strings
*     that match XXXX_ (position of * or @ set the length compared)..
*
*                                         08:47 PM WED., 18 Feb., 1987
*
 
*   bit_state   - state of the bit to be set (set to zero if
*               - minus sign preceeds the type)
*   conts(1)    - The contributions bit map.  A bit is set for
*               - each contribution to be set
*   default_cont(1) - The default contribution pattern.  Set when
*               - the RESET command is given.
*   dummy       - dummy value used as place holder in READ_LINE
*   i           - Loop counter
*   iel         - index in cont_types which matches the next
*               - command in buffer.
*   ierr        - Error flag from READ_LINE.  Error generated
*               - by either by IOSTAT error on read, or -1
*               - generated by reaching the end of the string.
*   indx        - Index used to keep track of where we are
*               - the buffer (used by READ_LINE)
*   next_cont_len   - length of the next_cont string found
*   num_types   - number of contributions allowed. Gives the
*               - length cont_types array.  This value is also
*               - used to compute number of words in the bit
*               - mapped conts when the default value needs to
*               - be assigned.
*   num_words   - number of words in Default_cont (computed from
*               - num_types)
*   trimlen     - HP function to return length of a string
*   iwc         - Position of wild card in name
 
      integer*4 bit_state, conts(*), default_cont(*), dummy, i, iel,
     .    ierr, indx, next_cont_len, num_types, num_words, trimlen, iwc
 
*   buffer      - line read from the Markov file.  Should contain
*               - the list of contributions to be applied or
*               - reset (if minus sign used)
*   cont_types(1)   - the array of types which are set.  This
*               - array must have the entries in the same order
*               - which the bits will be set.
 
      character*(*) buffer, cont_types(*)
 
*   next_cont   - The next contribution string from buffer.  One
*               - extra character is added to allow for plus or
*               - minus sign.
 
      character*25 next_cont
 
***** Loop through the buffer getting all the contrubution names
*     until we run out of entries or an error (ierr.ne.0)
 
      ierr = 0
*                 ! Start at the beginning of the line
      indx = 1
 
      do while ( ierr.eq.0 )
 
*         Get the next string in buffer
          call read_line( buffer, indx, 'CH', ierr, dummy, next_cont)
          call casefold(next_cont)
          if( next_cont(1:1).eq.'#' .or. 
     .        next_cont(1:1).eq.'!' ) ierr = -1
 
*         Only process if ierr is zero (no error)
          if( ierr.eq.0 ) then
 
*             strip + or - sign from start of next_cont and set
*             bit_state acordingly
              call get_bit_state( next_cont, bit_state)
 
*             Now see if we can find this contribution, if we cant
*             ignore entry unless it is RESET.
 
*                             ! Set not found value
              iel = -1
              i = 0
              next_cont_len = min( len(cont_types(1)),
     .                            trimlen( next_cont ) )
* MOD TAH 030607: Check for wild cards in the next_cont string
              iwc = 0
              iwc = index(next_cont,'*')
              if( iwc.eq.0 ) iwc = index(next_cont,'@')
              if( iwc.gt.0 ) next_cont_len = min(next_cont_len,iwc-1)
* MOD TAH 030607: Removed check on finding element so that all are searched
*             when there is a wild card.  (Short strings will now find all
*             as well)
              do while ( i.lt.num_types )
 
                  i = i + 1
                  if( cont_types(i)(1:next_cont_len) .eq.
     .                next_cont(1:next_cont_len)         ) then
                      iel = i
* MOD TAH 030607:     Set the bit as we find each element.
                      call sbit(conts,iel,bit_state)
                  endif

              end do
 
*             If we found next_cont then set bit in cont according to
*             bit state
 
*                                     ! Found
              if( iel.le.0 ) then
*                 No matches found, see if a prest value
                  num_words = (num_types+31)/32
                  if( next_cont(1:6).eq.'RESET ' ) then
*                                     ! default value.
                      do i = 1,num_words
                          conts(i) = default_cont(i)
                      end do
*                                     ! RESET cont
                  end if
                  if( next_cont(1:4).eq.'ALL ' ) then
                      do i = 1, num_words
                         conts(i) = -1
                      end do 
                  end if
*                                                      ! Clear values
                  if( next_cont(1:6).eq.'CLEAR ' .or.
     .                next_cont(1:5).eq.'NONE '      ) then
                      do i = 1,num_words
                          conts(i) = 0
                      end do
*                                     ! CLEAR conts
                  end if
*                                     ! contribution found
              end if
*                                     ! no error reading buffer
          end if
*                                     ! looping until end of string
      end do
 
***** Thats all
      return
      end
 

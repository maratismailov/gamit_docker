 
      program gapr_to_l

      implicit none
 
*     Program to convert the cartesian GLOBK apriori files to GAMIT
*     Lfile format.
 
*     The runstring of the program is:
*     % gapr_to_l <globk.apr> <lfile> <full names> <date> [eq file]
*
*     where <globk.apr> is the name of the input GLOBK apriori file,
*           <lfile> is the name of the output Lfile
* MOD TA 191226: Added different output files based on extent to file name
*                  (1) .apr : If name ends in .apr; EXTENDED terms are applied
*                      and XYZ file is generated.
*                  (2) +EXT : If name ends in +EXT, then the eq_file will
*                      be used to ensure the EXTENDED terms are ourput
*                      for new sites that need them (e.g., a rename after
*                      orginal ITRF2014 EATENCED tersm were created.).
*                      The EXTENDED terms are mot applied so these files.
*                      The +EXT is removed from the file name
*           <full names> is the name of a file which gives the full site
*                       name for each of the GAMIT four character site
*                       site codes. (This file is optional, the code
*                       is used if no file is given)
*           <date> is the date to which the Lfile coordinates should
*                       by referred.  Date may be specified in one of
*                       three ways:
*                       (1) If a single value is given, then decimal
*                           years is assumed,
*                       (2) If two values are given, then assumed to be
*                           year and day of year.
*                       (3) If three values are given assummed to be
*                           year, month, day.  
*          [eq file] is an optional earthquake file with renames and earthquakes
*             that is used to map sites back to there correct locations.  If
*             multiple renames have been used, these should be given in the
*             reverse order to that used in globk (basically so that they
*             can be undone in sequence).  Any position changes in the eq_file
*             are applied so care should be excercised if the problem which
*             required the position change orginally has been corrected
*             (e.g. an incorrect antenna height). 
*       
*       CAUTION: When the [eq file] option is used, the names generated by the
*       eq file are expected to be in the apr file.  If they are not present
*       then no entry is output to the lfile.  The exclusion for this rule is for
*       sites named to end in _XCL which will be excluded from the globk output.
*       In this case the original site name ending in _GPS will be output.  Missing
*       names will arise if a site is renamed and then excluded from the globk
*       solution using the use_site command. 
*
* MOD TAH 191226: Modified to create GAMIT .apr lfile that includes EXTENDED
*     terms.  The globk rouitnes are used to tod this.   

      include 'gapr_to_l.h'
      include '../includes/kalman_param.h'
      include '../includes/globk_common.h'
 
* MAIN PROGRAM VARIABLES
 
*   ierr        - IOSTAT error
*   trimlen     - Used length of string
*   out_unit        - Output unit number (200, unless 6 specified as
*               - output file)
 
      integer*4 ierr, trimlen, out_unit
 
*   line        - Line read from globk apriori file
 
 
      character*256 line

      integer*4 i, j, k, ! Loop counters
     .          indx, jndx, ! Position in string
     .          is,   ! Site number while reading apriori file
     .          jerr  ! Multiread error stat
 
      character*8 name    ! Name of site
      character*8 cd      ! Dummy string

      real*8 xyz(3)       ! Compuuted coordintes of site at epoch
     .,      nonsec(3)    ! Non-secualae XYZ value
     .,      dec_yrs      ! Reference epoch for site (years)
     .,      dummy(7)     ! Place holder to get to end of apriori 
                          ! coordinate line.

c      external globk_cmd_bd
 
****  Decode the runstring (Also get the reference epoch into
*     deciminal year form)
 
      call get_gapr_runstring

 
****  Now open up the globk apriori file
      open( 100, file = globk_apr_file, status='old', iostat=ierr)
      call report_error('IOSTAT',ierr,'open', globk_apr_file, 1,
     .                'GAPR_TO_L/GLOBK APRIORI')
 
****  See if the full name file has been given, if so open and read
 
      call get_full_names
 
*     Open the output file
 
      out_unit = 200
      call open_lu(out_unit,lfile, ierr, 'unknown' )
      call report_error('IOSTAT',ierr,'open',lfile, 1,
     .                'GAPR_TO_L/LFILE OUTPUT')
 
***** Write the header for the l-file
 
      call write_lfile_header( out_unit )

***** Now loop over the apriori file, converting and outputing
 
      ierr = 0
*     For l-file we can run sequentially.  For .apr file need to read
*     all enties first (so that the EXTENDED enties can be evaluated)
      if( aprf_out ) then
*        With thss form we need to read whole file first.  
*        Read once to get namesa of stations.
         do while ( ierr.eq.0 )
             read(100,'(a)', iostat=ierr) line
             if( ierr.eq.0 .and. trimlen(line).gt.0       
     .                     .and. line(1:1).eq.' ') then
*                Make sure not extended
                 indx = 1
                 call getword(line,name,indx)
                 call casefold(name)
                 if( name(1:8).ne.'EXTENDED' ) then
*                   Add site to list of sites
                    jndx = 1
                    call get_cmd(name, gsite_names, gnum_sites, is,
     .                             jndx )
                    if( is.lt.1 ) then
                        gnum_sites = gnum_sites+1
                        if( gnum_sites.gt. max_glb_sites )
     .                  call report_stat('FATAL','GAPR_TO_L','main',
     .                         ' ','Num site exceeds max_glb_sites', 
     .                              max_glb_sites)
                        gsite_names(gnum_sites) = name
*                       Save any comments are end of line
                        call multiread(line,indx,'R8',jerr, dummy,cd, 7)
                        site_comment(gnum_sites) = line(indx:)
                    endif
                 endif
              endif
          enddo 

          write(*,220) gnum_sites
 220      format('Creating GLOBK style L-file for ',i6,' sites')
*         Now use globk routines to read the apr file
          close(100)
          num_apr_files = 1
          glb_apr_file(1) = globk_apr_file

*         Read the aproiri file
          call get_apr_positions
****      Write Reference Frame
          write(out_unit,230) gnum_sites, num_nonsec
 230      format('* ',i5,' Sites with ',i6,' non-secular terms')
 240      format('* Additional EXTENDED entries added based on ',
     .           'eq_file ',a)
          write(out_unit,250) reference_frame
 250      format('+REFERENCE_FRAME ',a,/,
     .           '*  Site        X (m)           Y (m)          Z (m)',
     .           '      Vx (m/y)   Vy (m/y)   Vz (m/y) Year')

****      OK now loop over sites evaluating position.

          do i = 1, gnum_sites
             if( .not. ext_out ) then 
                 call eval_nonsec(i, lfile_jd, num_nonsec, 
     .                      param_nonsec, apr_val_nonsec, nonsec,0)

                 do j = 1,3
                    xyz(j) = apr_val_site(j,1,i) +
     .                       apr_val_site(j,2,i)*
     .                          (lfile_jd-site_epoch(i))/365.25d0 +
     ,                       nonsec(j)
                 end do
                 call jd_to_decyrs(lfile_jd, dec_yrs)
                 write(out_unit,320) gsite_names(i), xyz,
     .                          apr_val_site(:,2,i), dec_yrs, nonsec
 320             format(1x,a8,1x,3(f14.5,1x),3(f10.5,1x),f8.3,
     .               ' ! Non-secular ',3F10.5,' m')
            else
*                For this site scan the EQ_entries to see if 
*                extended entries are needed.  Map position to 
*                reference epoch as well.
                 do j = 1,3
                    xyz(j) = apr_val_site(j,1,i) +
     .                       apr_val_site(j,2,i)*
     .                          (lfile_jd-site_epoch(i))/365.25d0 
                 end do
                 call jd_to_decyrs(lfile_jd, dec_yrs)
                 write(out_unit,340) gsite_names(i), xyz,
     .                          apr_val_site(:,2,i), dec_yrs,
     .                          trim(site_comment(i))
340             format(1x,a8,1x,3(f14.5,1x),3(f10.5,1x),f8.3,
     .               ' ! ',a)
 
*****            Now look for and out put extended terms
                 call get_locsec( i )
                 if( num_locsec.gt.0 ) then
*                   OK found values, so output
                    call wr_locsec( out_unit, i )
                 else   ! Non-found for this site; See if we can find
                     ! from a renamed site.
*                   Look back in sites to see if any name matches
                    do k = i-1,1,-1   ! We will exist if name changes
                       if( gsite_names(k)(1:4).eq.
     .                     gsite_names(i)(1:4) ) then
                          call get_locsec( k )
                          if( num_locsec.gt.0 ) then
                             call wr_locsec( out_unit, i )
                             exit   ! Done so exist loop
                          endif
                       else
                          exit      ! Done, no name found
                       endif
                    enddo
                 endif
             end if

           end do   

      else
*        Old code that works sequentially through file.

         do while ( ierr.eq.0 )
             read(100,'(a)', iostat=ierr) line
             if( ierr.eq.0 .and. trimlen(line).gt.0 ) then
 
*                See if first character is non-blank
*                                            ! Write as comment
                 if( line(1:1).ne.' ' ) then
                     write(*,'(a)') line(1:trimlen(line))
*                                            ! Decode line and output
                 else
                     call make_lfile( out_unit, line )
                 end if
             end if
         end do
      endif

****  Thats all
      write(*,420) trim(lfile)
 420  format('Created output ',a)
      close(100)
      close(out_unit)
 
      end
 
CTITLE GET_GAPR_RUNSTRING
 
      subroutine get_gapr_runstring

      implicit none

*     Routine to decode the runstring for gapr_to_l
 
      include 'gapr_to_l.h'
      include '../includes/kalman_param.h'
      include '../includes/globk_common.h'
      include '../includes/globk_cmds.h'

 
* LOCAL VARIABLES
 
*   rcpar       - Function to read runstring
*   len_run     - Length of the runstring values
*   ierr        - IOSTAT error
*   date(5)     - Date used to convert to Julian date
*   num_dates   - Number of dates passed (used to see if year,
*                 year day, or year month day)
 
      integer*4 rcpar, len_run, ierr, date(5), num_dates, jerr
 
*   sectag      - Seconds tag for julian date routine
*   year        - Year read from runstring
*   monday      - Either month or day of year
*   day         - Day of month
*   jd          - Julian date of reference epoch.
 
 
      real*8 sectag, year, monday, day, jd

*    date_string - String used to hold the date information

      character*120 date_string

*     initialize name of the earthquake file
      eq_inp_file(1) = ' '
 
****  Get the name of input globk apriori file
 
      len_run = rcpar(1, globk_apr_file )
      if( len_run.le.0 ) then
          call proper_runstring('gapr_to_l.hlp',
     .                        'gapr_to_l/globk apriori', 1)
      end if
 
*     Get name of lfile.  If no name passed output to stdout
      len_run = rcpar(2, lfile )
      ext_out = .false.
      if( len_run.le.0 ) then
          lfile = '6'
          aprf_out = .true.
      elseif( lfile(len_run-3:len_run).eq.'.apr' ) then
          aprf_out = .true.
      elseif( lfile(len_run-3:len_run).eq.'+EXT' ) then
          aprf_out = .true.
          ext_out = .true.
          lfile(len_run-3:) = ' '  ! Clear end of name
      else    ! Orginial mode for gapr_to_l
          aprf_out = .false.
      end if
 
*     Get the full site name file.  If no given just set name blank
*     and names will be generated
 
      len_run = rcpar( 3, full_name_file)
      if( len_run.le.0 ) then
          full_name_file = ' '
      end if
 
****  Now get the epoch argument
      num_dates = 0
      len_run = rcpar(4, date_string )
      if( len_run.le.0 ) then
          call proper_runstring('gapr_to_l.hlp',
     .                        'gapr_to_l/Year', 1)
*                     ! Decode the year string
      else
          read(date_string,*, iostat=ierr ) year
          call report_error('IOSTAT',ierr,'decod', date_string,1,
     .        'GET_GAPR_RUNSTRING/YEAR_STRING')
          num_dates = num_dates + 1  
          if ( year.lt.70) year = year + 2000.d0
          if ( year.lt.100.and.year.ge.70) year = year + 1900.d0
      end if
 
****  Try next argument
      len_run = rcpar(5, date_string )

*     See if numerical value
      jerr = 0
      if( len_run.gt.0 ) call check_num(date_string,jerr)
      if( len_run.gt.0 ) then
          if( jerr.eq.0 ) then   ! Numeric argument so decde.
             read(date_string,*,iostat=ierr) monday
             call report_error('IOSTAT',ierr,'decod', date_string,1,
     .           'GET_GAPR_RUNSTRING/MONTH/DAY_STRING')
             num_dates = num_dates + 1
          else
            eq_inp_file(1) = date_string
          end if
      end if
 
***** Try to get next argument
      len_run = rcpar(6, date_string )
      if( len_run.gt.0 ) call check_num(date_string,jerr)
      if( len_run.gt.0 ) then 
          if( jerr.eq.0 ) then
             read(date_string,*,iostat=ierr) day
             call report_error('IOSTAT',ierr,'decod', date_string,1,
     .           'GET_GAPR_RUNSTRING/DAY_STRING')
             num_dates = num_dates + 1
          else
             eq_inp_file(1) = date_string
          end if
      end if

****  Finally see if earthquake file name passed
      len_run = rcpar(7, date_string)
      if( len_run.gt.0 ) eq_inp_file(1) = date_string

****  Now depending on the number of arguments convert to
*     decimal years.  Set some defaults date entries
      date(2) = 1
      date(3) = 1
      date(4) = 0
      date(5) = 0
      sectag  = 0
 
*                                     ! Decimal year given
      if( num_dates.eq.1 ) then
          lfile_epoch = year
          call decyrs_to_jd( lfile_epoch, jd)

*                                     ! Year and day number
      else if ( num_dates.eq.2) then
          date(1) = year
          call ymdhms_to_jd( date, sectag, jd)
          jd = jd + monday - 1
          call jd_to_decyrs( jd, lfile_epoch)
*                                     ! Year, month, day
      else if ( num_dates.eq.3 ) then
          date(1) = year
          date(2) = monday
          date(3) = day
          call ymdhms_to_jd( date, sectag, jd)
          jd = jd + monday - 1
          call jd_to_decyrs( jd, lfile_epoch)
      end if

      lfile_jd = jd

****  Finally read the eartquake file if name given
      call read_eq_file
 
****  OK we are all done
      return
      end
 
CTITLE GET_FULL_NAMES
 
      subroutine get_full_names
 
      implicit none

*     Routine to read the full names file and make up the list
*     codes and full names for the lfile.
 
      include 'gapr_to_l.h'
 
* LOCAL VARIABLES
 
*   ierr,jerr   - IOSTAT errors
*   trimlen     - Length of string
*   indx        - position in string
 
      integer*4 ierr,jerr, trimlen, indx
 
*   line    - Line read from file
 
      character*256 line
 
*   first_string    - First string in line (site code)
 
      character*8 first_string
 
*   second_string   - Next string (read as 12 charcaters)
 
      character*32 second_string
 
****  Try to open the full_name_file
      num_full = 0
      if( trimlen(full_name_file).eq.0 ) RETURN
 
      open(101, file=full_name_file,iostat=ierr, status='old')
      call report_error('IOSTAT',ierr,'open',full_name_file, 0,
     .                'GET_FULL_NAMES')
 
*     Now loop over the file
      do while ( ierr.eq.0 )
 
          read(101, '(a)', iostat=ierr) line
          if( ierr.eq.0 .and. trimlen(line).gt.0 .and.
*                                     ! Decode
     .        line(1:1).eq.' ' ) then
              indx = 1
              call getword(line, first_string, indx)
              num_full = num_full + 1
 
*****         See if too many sites
              if( num_full.eq.max_gtols ) then
                  write(*,100) num_full
  100             format(' Maximum number of sites ',i4,
     .                ' reached.  No more codes will be read')
                  ierr = -1
              end if
 
              call casefold( first_string )
              code_names(num_full) = first_string
              read(line(indx:),'(a12)',iostat=jerr) second_string
              call report_error('IOSTAT',ierr,'read',line,
     .                 0,'GET_FULL_NAMES/Full name')
              call trimlead(second_string)
              full_names(num_full) = second_string
          end if
      end do
 
****  Thats all
      close(101)
      return
      end
 
CTITLE WRITE_LFILE_HEADER
 
      subroutine write_lfile_header (out_unit )
 
      implicit none

*     Routine to write the one-line header in the lfile.  Just
*     the globk apr file name and epoch are put in header
 
      include 'gapr_to_l.h'
 
* PASSED VARIABLES
 
*   out_unit        - OutPut unit number
 
      integer*4 out_unit
 
* LOCAL VARIABLES
 
*   ierr    - IOSTAT error
*   trimlen - Length of string
 
 
      integer*4 ierr, trimlen
 
***** Write out the one-line header
 
      write(out_unit, 100, iostat=ierr ) lfile_epoch,
     .    globk_apr_file(1:trimlen(globk_apr_file))
 100  format('* GAPR_TO_L: Epoch ',F9.4,': From apr file ',a)
      call report_error('IOSTAT',ierr,'writ',lfile,1,
     .                'write_lfile_header')
 
****  Thats all
      return
      end
 
CTITLE MAKE_LFILE
 
      subroutine make_lfile( out_unit, line )

      implicit none
 
*     Routine to make the Lfile entry for this station.  The
*     line read from the apriori file is decoded, the full name
*     deterimined and the output written. 

      include '../includes/kalman_param.h'
      include '../includes/globk_common.h'
      include '../includes/globk_cmds.h'
 
      include 'gapr_to_l.h'
      include '../includes/const_param.h'
 
* PASSED VARIABLES
 
*   out_unit        - Output unit number
 
      integer*4 out_unit
 
*   line        - Line read from input.
 
      character*(*) line
 
* LOCAL VARIABLES
 
*   indx        - Position in string
*   iel         - Code number
*   lat_deg, long_deg       - Lat and long degrees
*   lat_min, long_min       - Lat and lonf minutes
*   ierr        - IOSTAT error
*   status      - Status returned from check_eq, -1 not found
*                 0 found OK, >0 do not output site.
 
      integer*4 indx, iel, ierr, jndx, status

      real*8 lat_deg, long_deg, lat_min, long_min
 
*   values(7)   - XYZ, Xdot, Ydot, Zdot and epoch
*               - read from input
*   dt          - Time difference in years
*   ref_epoch   - Refence epoch for site
*   xyz(3)      - Postion of site at lfile_epoch
*   rot_mat(3,3)    - Rotation from XYZ to NEU (Not used)
*   llr(3)      - Latitude, Longitude, radius (rad, m)
*   lat_sec, long_sec   - Lat and Lonf seconds
 
      real*8 values(7), dt, ref_epoch, xyz(3), rot_mat(3,3), llr(3),
     .    lat_sec, long_sec
 
*   lat_lab, long_lab   - Labels for Lat and Long sign.
 
      character*4 lat_lab, long_lab
 
*   gtolsn        - Name of apriori site
*   cdum        - String for multiread
 
      character*8 gtolsn, cdum, globk_name
 
*   apr_full        - Full name for apriori site
 
 
      character*32 apr_full
 
***** Get the name of the site.
 
      indx = 1
      call casefold( line )
      call getword( line, gtolsn, indx )

****  Now get the position and velocity for this site
      call multiread(line, indx, 'R8', ierr, values, cdum, 7)
 
*     If _GPS is in name then remove.  If site is not a GPS site
*     then just return.  (Avoids problem of HAYSTACK being trunacted
*     to HAYS).

      globk_name = gtolsn   
      call check_eq( gtolsn, values, status )  

*     Check the return status: If -1 then site not found so
*     do normal check, if 0 site found fine and Ok to continue
*     if >0 then not correct site to output
      if( status.gt.0 ) RETURN
      if( status.eq.-1 ) then 
          if( gtolsn(5:6).ne.'_G') RETURN
      endif
 
*     Set name back to 4 character code
      gtolsn(5:8) = ' '
 
****  Now see if we can find a full name
      jndx = 1 
      call get_cmd( gtolsn, code_names, num_full, iel, jndx)

****  
 
*     See if found. If not fake the name
      if( iel.le.0 ) then
          apr_full = gtolsn(1:4) // ' GPS '
      else
          apr_full = full_names(iel)
      end if
 
 
*     if no error then continue
      if( ierr.eq.0 ) then
 
*****     Get the position at the correct epoch
          ref_epoch = values(7)
          if( ref_epoch.lt. 50.0 ) ref_epoch = ref_epoch + 2000.d0
          if( ref_epoch.lt.100.0 ) ref_epoch = ref_epoch + 1900.d0
          dt = lfile_epoch - ref_epoch
          xyz(1) = values(1) + values(4)*dt
          xyz(2) = values(2) + values(5)*dt
          xyz(3) = values(3) + values(6)*dt
 
          call XYZ_to_NEU( rot_mat, xyz, llr )

*         Convert co-latitude to latitude
          llr(1) = pi/2.d0 - llr(1)
 
****      Convert the lat and long to milliarc seconds
          llr(1) = llr(1) * rad_to_mas
          llr(2) = llr(2) * rad_to_mas
 
*         Now get the sign on each, and save as NS or EW
          if( llr(1).lt.0.d0 ) then
              lat_lab = 'S'
          else
              lat_lab = 'N'
          end if
          if( llr(2).lt.0.d0 ) then
              long_lab = 'W'
          else
              long_lab = 'E'
          end if
 
*****     Now convert on the absolute values
          llr(1) = abs(llr(1))
          llr(2) = abs(llr(2))
 
          call mas_to_dms( llr(1), lat_deg,  lat_min,  lat_sec )
          call mas_to_dms( llr(2), long_deg, long_min, long_sec)
 
*****     Now write out the line
          write(out_unit, 200) gtolsn, apr_full,
     .            lat_lab, nint(lat_deg), nint(lat_min),  lat_sec,
     .            long_lab, nint(long_deg), nint(long_min), long_sec,
     .            llr(3), ref_epoch, globk_name
 200      format(a4,1x,a12,a1,i2,i3,f9.5,1x,a1,i3,i3,f9.5,1x,f12.4,
     .            ' Ref. Epoch ',f9.4,1x,a8)
      end if
 
****  Thats all
      return
      end
 
CTITLE CHECK_EQ

      subroutine check_eq( gtolsn, site_pos, status )

      implicit none

*     Routine to see if we can find site name in the renames
*     can earthquake list
 
      include '../includes/kalman_param.h'
      include '../includes/globk_common.h'
 
      include 'gapr_to_l.h'
      include '../includes/const_param.h'
 
* PASSED
*   site_pos(3) - XYZ of site to see if influenced by earthquake
      real*8 site_pos(3)

*   status      - Status returned from check_eq, -1 not found
*                 0 found OK, >0 do not output site.
 
      integer*4 status

*   gtolsn    - Name of site read from apr file

      character*(*) gtolsn

* LOCAL VARIABLES
*   i  - loop counter
*   neq  - Earthquake number applicable to site

      integer*4 i, j, neq
   
*   dist - distance from hypocenter
      real*8 dist 

*   eq_affected -- set true if site affected by earthquake
      logical eq_affected

*   eq_name -- Name of earthquake affecting site.  If prior
*     to first earthquake then set to 'PS' for standard _GPS
*     site name

      character*8 eq_name

****  Check the renames before the EQs (this logic assumes that all the renamed
****  sites in the apr file have entries in the rename list)

*     initialize set the status flag to indicate 'not found in EQ file; therefore write out as is
      status = -1
  
      do i = 1, num_renames
                                     
**    RWK 011030: added logic here to avoid duplicates in the case where there is an
**                entry in the rename list for the  wrong time span

*        See if the apr name matches after a rename
         if( gtolsn.eq.rn_codes(2,i) ) then
            if( lfile_jd.ge. rn_times(1,i) .and.
     .          lfile_jd.le. rn_times(2,i) ) then
*             if the time matches set 'status=0' to write the apr entry to the l-file
              status = 0
*             change the name back to the original and remove adjustments that were
*             applied to the position (rwk:  why do this?)
              gtolsn = rn_codes(1,i)
              do j = 1, 3 
                site_pos(j) = site_pos(j) - rn_dpos(j,i)
              end do
            else
*             if the times don't match, set status=1 to avoid writing the entry in the l-file
              status = 1
            endif
*        If the original name matches but the rename is _XCL globk will not have output the 
*        value, so we need to use the original (status = 0).
         else if( lfile_jd.ge. rn_times(1,i) .and.
     .       lfile_jd.le. rn_times(2,i) .and.
     .       gtolsn.eq. rn_codes(1,i)     ) then   
             if( rn_codes(2,i)(5:8).eq.'_XCL' ) then
                status = 0
                gtolsn = rn_codes(1,i)
             else
                status = 1
             endif
         end if

      end do
  
*     Skip the EQ check if we have found a rename entry in the file
      if( status.ge.0 ) RETURN

*     Now check the earthquake.  Since the earthquakes are in
*     time order, this code should generate the latest earthquake
*     applicable to this site.
      neq = 0
      eq_affected = .false.
      eq_name = 'PS'

      do i = 1, num_eq
*         See if this site will be influenced by the earthquake.
          dist = sqrt((site_pos(1)-eq_pos(1,i))**2+
     .                (site_pos(2)-eq_pos(2,i))**2+
     .                (site_pos(3)-eq_pos(3,i))**2)
          if( dist.le.eq_rad(i) .and. eq_rename(i) ) then

*              So this site is inside the region that will
*              be affected by this earthquake.  Now see if
*              the timing is correct.
               eq_affected = .true.
               if( lfile_jd.ge.eq_epoch(i) )
     .              eq_name = eq_codes(i)(1:2)
          end if 
      end do

*     If we end up with an earthquake effected site
      if( eq_affected ) then
          status = 1
          if( gtolsn(7:8).eq.eq_name(1:2) ) then
              status = 0
*             Set the name back so that Long site name is
*             found.
              gtolsn(7:8) = 'PS'
          end if
      end if

****  Thats all
      return
      end

CTITLE GET_LOCSEC

      subroutine get_locsec( is )

      implicit none

*     Routine to return all of the non-secular terms at station
*     number is.

      include '../includes/kalman_param.h'
      include '../includes/globk_common.h'
 
      include 'gapr_to_l.h'

* PASSED VARIABLE (IN)
      integer*4 is  ! station number

* LOCAL 
      integer*4 i ! Local loop variables

***** SCAN through the non-sec terms to find station
      num_locsec = 0
      do i = 1, num_nonsec
         if( param_nonsec(1,i).eq.is ) then
*          Found the stattion so save
           num_locsec = num_locsec+1
           if( num_locsec.gt.max_locsec ) then
              stop 'GAPR_TO_L: max_locsec exceeded'
           endif
           param_locsec(:,num_locsec) = param_nonsec(:,i)
           apr_val_locsec(:,num_locsec) = apr_val_nonsec(:,i)
         endif
      enddo

***** Thats all
      return 
      end

CTILTE WR_LOCSEC
 
      subroutine wr_locsec( out_unit, ir )

      implicit none

*     Routine to write EXTENDED lines based on values from
*     site IR

      include '../includes/kalman_param.h'
      include '../includes/globk_common.h'
 
      include 'gapr_to_l.h'

* PASSED VARIABLE (IN)
      integer*4 out_unit,   ! Output unit number
     .          ir  ! station number 

* LOCAL 
      integer*4 i,j, k  ! Local loop variables
      integer*4 date(5)  ! YYYY, MM, DD, Hr, Min.
      integer*4 it       ! Type of non-sec term
      integer*4 is       ! Site number
      real*8 vals_neu(6)   ! Non-sec converted back to NEU
      real*8 sectag, deps        ! Seconds

      deps = 1.d-5   !  ~ 1sec.
     

*     Test first
      do i = 1,num_locsec
*        Convert XYZ values back to NEU for output
         call nonsec_convert('TONEU',1,apr_val_locsec(3,i),
     .          vals_neu,apr_val_site(1,1,ir))
         call jd_to_ymdhms(apr_val_locsec(1,i)+deps,date,sectag)
         is = param_locsec(1,i) 
         it = param_locsec(2,i) 
         if( it.eq.3 .or. it.eq.4 ) then   ! LOG/EXP ty[e
             write(out_unit,420) gsite_names(ir), nonsec_types(it),
     .           date, apr_val_locsec(2,i), (vals_neu(j),j=1,3),
     .           gsite_names(is)
        
 420         format(' EXTENDED ',a8,1x,a8,1x,i5,4i3,F12.3,3F9.5,28x,
     .              ' ! From Site ',a) 
         else
             write(out_unit,440) gsite_names(ir), nonsec_types(it),
     .           date, apr_val_nonsec(2,i), vals_neu, 
     .           gsite_names(is)
 440         format(' EXTENDED ',a8,1x,a8,1x,i5,4i3,F8.3,6F9.5,1x,
     .              3F9.5,' ! From site ',a)
         endif
      enddo 


****  Thats all
      return
      end


*     Include the block data in the main program since some compilers/linkers (specifically OSX) will not correctly 
*     load the initialized block data routines from library archives.
      include '../globk/globk_cmd_bd.f' 
 
